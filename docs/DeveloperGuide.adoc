= StudyBuddyPro - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-W13-3/main

By: `Team AY1920S1-CS2103T-W13-3`

== Introduction

Welcome to StudyBuddyPro!

StudyBuddyPro is a desktop-based application with a Graphical User Interface (GUI). It is intended for students in the School of Computing at National University of Singapore (NUS) who prefer to work with a Command Line Interface (CLI).

StudyBuddyPro aims to lessen target users' revision time consumption without compromising the quality of studies. The application provides a centralized platform for them to revise using flashcards, take notes and generate cheatsheets.

This Developer Guide (DG) is written for anyone who wishes to contribute to our project. In here, you will find StudyBuddyPro's information for set-ups, its architectures and its key features.

If you wish to know more details about StudyBuddyPro, please do not hesitate to
https://ay1920s1-cs2103t-w13-3.github.io/main/ContactUs.html[contact us]!

=== Callouts Signs

Do refer to the signs below that will be used across the documents for references. These will prove to be useful when you are reading this document.

[WARNING]
====
Indicates information that are to be adhere as potential problems may be encountered if you are not careful.
====


[IMPORTANT]
====
Indicates information that are crucial to understand so that you will be able to follow the flow of the document. Confusion may arise if you do not grasp the information here.
====

[NOTE]
====
Indicates information that are note-worthy. Do read them for more information and better understandings.
====

[TIP]
====
Indicates additional information that are helpful. Fret not, tips can be good to know but are not vital.
====

=== Syntax

Do refer to _Table 1_ below for the various syntax that will be used across the documents for references. These will prove to be useful when you are reading this document.

.Syntax Table
[options = "header"]
|===
| Syntax | Usage
| *`exampleCommand`*  | Indicates technical terms like _commands_, _classes_ and _methods_
| link:#1[link] | Indicates internal/external links
|===

These syntax will be used in any context across the document. Possible places that they may appear are in _examples_, _explanations_ and _descriptions_. Take note of these syntax as they may have different meaning compared to normal texts!

For example, `switch` is a command for you to type in the CLI so that the function can be executed. However, 'switch' in plain text can mean the switch device itself or to switch amongst some things.

====
An example of `switch` versus 'switch':

- ... `switch` to toggle between the features ...
- ... is able to switch between features ...
====

== Setting up

Do refer to the guide <<SettingUp#, here>> to set up our StudyBuddyPro on your device(s)!

== Design

The following sections will show how StudyBuddyPro is being constructed in details.

[[Design-Architecture]]
=== Architecture

The _figure_ below displays the high-level design of our StudyBuddy Pro.

.Architecture Diagram
image::ArchitectureDiagram.png[]

[TIP]
The `.puml` files used to create some of the diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

The architecture diagram describes the relationships between the components, and here is a quick overview of each component:

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component in _Figure 2_ defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

The `logic` component's class diagram shows the relationships between the components it interacts with. Also, it provides the flow of the actions with arrows.

[discrete]
==== How the application modes works?

The _StudyBuddy Pro_ application has 3 modes for all the features: Flashcard, Cheatsheet and Notes.
The users use `switch` command to switch between the modes.
In each mode, the users will interact with only the modes' commands, unless it is a _global_ command.

- `switch fc` - switches to flashcard mode
- `switch cs` - switches to cheatsheet mode
- `switch notes` - switches to notes mode

The following _figure_ is an activity diagram that describes the execution of the `switch` command.

.Activity Diagram of `Switch` command execution
image::jasmineDiagrams/SwitchActivityDiagram.png[]

From the activity diagram above, it shows the logic flow of the actions taken when user executes the `switch` command. Also, it shows the checks taken placed to verify the command that was parsed.

[discrete]
==== How the architecture components interact with each other

The _figure_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

[IMPORTANT]
====
Assuming that the user is currently in the _flashcard_ mode.
====

.Sequence diagram of component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The above sequence diagram illustrates the relationships between each components in the StudyBuddyPro's architecture. The sections below will give more details of each of those components.

[[Design-Ui]]
=== User Interface (UI) component

This section describes the behaviour of the `UI` component in details.
The _figure_ below portrays the internal structures of the `UI` components and their interactions.

.Class diagram of the structure of the `UI` Component
image::UiClassDiagram.png[]

The class diagram above draws out the relationships between the internal components and their flow of actions.
The segment below provides more details of the `UI` components and its API's link.

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `ActivityWindow`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

This section describes the behaviour of the `logic` component in details.
The _figure_ below portrays the internal structures of the `logic` components and their interactions.

[[fig-LogicClassDiagram]]
.Class diagram of the structure of the `logic` Component
image::LogicClassDiagram.png[]

The class diagram above draws out the relationships between the internal components and their flow of actions.
The segment below provides more details of the `logic` components and its API's link.

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `StudyBuddyParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a cheatsheet).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

The _figure_ below is the sequence diagram for the interactions within the `Logic` component for the `execute("delete 1")` API call.

[IMPORTANT]
====
Assuming that the user is in the _flashcard_ mode.
====

.Sequence diagram for the interactions Inside the `logic` Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

[IMPORTANT]
====
The lifeline for `DeleteFlashcardCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.
====

The above sequence diagram clearly portrays the execution of the `delete 1` command with relevant _methods_ being called. Also, it provides the action flow and _return variables_ accordingly.

[[Design-Model]]
=== Model component

.Structure of the Model Component

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the StudyBuddyBook data.

[[Design-Storage]]
=== Storage component

This section describes the behaviour of the `storage` component in details.
The _figure_ below portrays the internal structures of the `storage` components and their interactions.

.Class diagram of the structure of the `Storage` Component
image::StorageClassDiagram.png[]

The class diagram above draws out the relationships between the internal components and their flow of actions.
The segment below provides more details of the `storage` components and its API's link.

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the StudyBuddyBook data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.studybuddy.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

=== Tagging Feature

==== Implementation

** The current implementation of StudyBuddyItems in StudyBuddyPro is such that it contains a Set of Tags.
** The following objects of each individual feature shares similar Tagging behaviour, as shown in the class diagram below.

image::kaibindiagrams/studyBuddyItemClassDiagram.png[]

==== Design Considerations

** As explained in the class diagram above, each StudyBuddyItem is limited to a total number of 10 tags.
** It is designed as such to prevent users from over-cluttering the result display when they view items that have too many tags.
** To reduce confusion for the user, all tags will be converted to lower-case upon initialization.

===== Aspect: How tag predicates are implemented

image::kaibindiagrams/tagPredicateClassDiagram.png[]
_Diagram 6: Class Diagram of how StudyBuddyItemContainsTagPredicate is implemented_

* The above class diagram shows how tag predicates are being implemented.

* The set of tags that is stored in `StudyBuddyItemContainsTagPredicate` refers to the tags specified by the user.

image::kaibindiagrams/tagPredicateCodeSnippet.png[]
_Diagram 7 : Code Snippet of `StudyBuddyItemContainsTagPredicate#test()`_

* The current implementation is that test() only returns true if *all* tags specified by the user matches the current Item.
* As such, there will be more correctness when auto-generating cheatsheets and filtering flashcards, as seen in the following example.
** If a user wishes to generate a cheatsheet and pull items with tags [cs2100] and [difficult], it would strictly only pull difficult CS2100 contents, and not pull other items
that might have tags containing [difficult].

==== Usage of Tags

===== a. To search for items

** Inside each feature
*** The user is able to specify a tag name to get a list view of all the items with that specified tag in the mode they are currently in (e.g. `filter tag/cs2100`).
** Searching using Tags globally
*** The user is also able to indicate a tag name get a list view of all the StudyBuddyItems across all 3 modes in StudyBuddyPro (e.g. `filterall tag/ma1521`).
** Currently, the user is able to specify multiple tags in his/her query (e.g. `filter tag/cs2100 tag/difficult`).
** If multiple tags are specified, only items that match all the specified tags will be listed.
** The sequence diagram below shows how listing all items across StudyBuddyPro by a specified tag works.

image::kaibindiagrams/ListAllByTagSequenceDiagram.png[]

Diagram 8 : Sequence diagram of filtering all StudyBuddyItems by a tag.

===== b. For Auto-generation of CheatSheets

** Upon adding a cheatsheet, the cheatsheet will make use of tags to automatically pull contents from other features of StudyBuddyPro.
** StudyBuddyItems with tags that match the user's input will be pulled over.
** This feature will be further elaborated in the next section, Section 4.4.

===== c. For TimeTrial Mode

** The TimeTrial Mode of the flashcard feature, will make use of the tagging feature.
** It will do so by filtering out flashcards with tags that match the user's input.
** For instance, if a user wishes to revise only important flashcards, he/she could enter the following command, `timetrial important`.

[IMPORTANT]
====
The syntax used here is slightly different. The user need not specify the `tag/` keyword to indicate that the item is a tag.
====
** The TimeTrial feature will be further elaborated in Section 4.5.

==== [Proposed] Future improvements

** Supporting deletion of Tags
*** Allow the user to delete a specified Tag.
*** All StudyBuddyItems must be updated in response to the deletion.
*** A proposed implementation would be to store all Tags in a Global Data Structure, and have each StudyBuddyItem reference to that Data Structure.
*** As such, we can apply an Observer pattern to update each StudyBuddyItem upon deletion of a tag.


tag::cheatsheetAutomation[]

=== Customizable Auto-generated Cheatsheet Feature

[IMPORTANT]
All the operations assume the user is in the _cheatsheet_ mode.

==== Implementation

This feature has a two-step implementation.
The first step is to auto-generate cheatsheet, and the second step is to enable removal of contents in the generated cheatsheet.

===== Step 1: Auto-generation

The auto-generation mechanism is used in the `AddCheatSheetCommand` during creation of the cheatsheet.
After creation, the cheatsheet is then stored in the `studyBuddyBook`.

It is involved in the following operations:

- `AddCheatSheetCommand#execute()` -- Creates the cheatsheet

- `AddCheatSheetCommand#getRelevantContents()` -- Gets all the contents from _flashcard_ and _notes_ according to the _tags_ specified

The first operation is exposed in the `Model` interface as `Model#setCheatSheet()`.

The following _figure_ shows a high-level view of how the auto-generation operation works.

.Sequence diagram to illustrate auto-generation operation
image::jasmineDiagrams/AddCheatSheetSequenceDiagram.png[pdfwidth=60%]

From the sequence diagram above, it portrays the relationships between the components to execute the creation mechanism. The _figure_ below explains the details within the sequence diagram.

.Detailed sequence diagram for retrieval of tagged contents
image::jasmineDiagrams/AddCheatSheetDetailedSequenceDiagram.png[pdfwidth=60%]

The above sequence diagram shows the complete action flow for the execution of methods.
Here is a brief summary of the steps taken to create the cheatsheet:

1. A new _cheatsheet_ object is created with the parsed _title_ and _tags_.

2. Another new _cheatsheet_ object is created with the relevant contents extracted according to the _tags_ specified.

3. The first _cheatsheet_ object is replaced with the second _cheatsheet_ object while retaining its _title_ and _tags_.

Different _cheatsheet_ objects are created to ensure that the _cheatsheet_ object itself is not modifiable.

===== Step 2: Customizing contents

The customization is based on the contents that the user wants to remove. The customization feature is used in the `EditCheatSheetCommand` during the editing of the cheatsheet. After the customization, the cheatsheet is then stored in the `studyBuddyBook`.

It is involved in the following operations:

- `EditCheatSheetCommand#execute()` -- Edits the cheatsheet

- `EditCheatSheetCommand#updateContents()` -- Retrieves the contents to be retained in the cheatsheet

The first operation is exposed in the `Model` interface as `Model#setCheatSheet()`.

The following _figure_ shows the activity flow how the customization feature works using an example command called `edit 1 c/1 c/3 c/7`.

[IMPORTANT]
====
The index provided after `c/` indicates the content to be _removed_, not to be _retained_.
====

.Activity diagram of the `edit` command for the removal of contents
image::jasmineDiagrams/EditCheatSheetCommandActivityDiagram.png[pdfwidth=50%,scaledwidth=50%]

The activity diagram above shows the general flow of customization of cheatsheet feature. The changes for _contents_ have to come first before the changes for _tags_. This is to ensure that the _contents_ are still relevant to the _tags_ specified. An example is provided below.

.Example of tags and contents in a cheatsheet titled "An Example"

|===
|Tag | Content

|tag1
|content1

|tag2
|content2

|tag2
|content3
|===

According to the above table, the system will be able to remove _tag2_ first before _content2_ if the order of removal is not followed. This may result in *potential errors* in the system as _content2_ may not be found or the position of it is being replaced with another content.

==== Design Considerations
===== Aspect: How auto-generation is implemented

* **Alternative 1 (current choice):** Replacing the newly created cheatsheet with another cheatsheet object containing all the relevant contents
** Pros: Retains the object originality and easier to implement.
** Cons: Invoking the edit method to create a new cheatsheet object may be complicated and messy.
* **Alternative 2:** Reformat the way the `add` function works and abstract it such that it will be generalized.
** Pros: Codes may be cleaner and easier to understand.
** Cons: Harder to implement. More abstraction and modifications have to be done. Might change the format of the system.

===== Aspect: How customization of contents is implemented

* **Alternative 1 (current choice):** Places all contents that are not within the indexes specified by users into a new cheatsheet object and the targeted cheatsheet object with the respective changes.
** Pros: Retains the object originality and easier to implement.
** Cons: Large amount of contents may result in longer processing time as it loops to find all contents not removed. It is messier to comprehend.
* **Alternative 2:** Reformat the way the `edit` function works and abstract it such that it will be generalized.
** Pros: Codes may be cleaner and easier to understand.
** Cons: Harder to implement. More abstraction and modifications have to be done.

end::cheatsheetAutomation[]

==== [Proposed] Future improvements

- Alerts users of possible duplications of contents
- Allows users to gauge the size of the contents (whether if it fits in single-sided or double-sided A4 paper)
- Allows users to export the cheatsheets
- Allows updates of cheatsheet
    -- Currently, contents are taken upon creation. Hence, any objects with specified tags will not be added into the cheatsheet after the creation of the cheatsheet.

=== Flashcards Time Trial Feature

[IMPORTANT]
The following commands assume that the user is in the _flashcard_ mode.

==== Implementation
a.	The time trial mechanism is facilitated by the `FlashcardTabWindowController`, and mainly uses the `Timeline`, `KeyFrame` and `KeyValue` class from the JavaFX package to support its functionality.

The following _figure_ shows a class diagram of the relevant classes of the time trial feature.

image::jrImages/TimeTrialClassDiagram.png[]

b.	Given below is an example usage scenario and how the time trial mechanism behaves at each step.
c. Upon initialization of the StudyBuddy and switching to the Flashcard window, the `StudyBuddyParser`’s function enum will be set to parse `Flashcard` commands.
d.	The user executes (timetrial cs2100), and the `StartTimeTrialCommand` retrieves a List of flashcards with the associated `Tag` through the `Model#getTaggedFlashcards`, which is then passed into the `FlashcardTabWindowController`.
e.	The `FlashcardTabWindowController` then calls the `FlashcardTabWindowController#startTimeTrial`, which in turns construct a `Timeline` with the following added for 3 flashcards:
1.	A `KeyFrame` to call the `FlashcardTabWindowController#loadTimeTrial` method, which displays the question of the flashcard on the window, with a `KeyValue` that starts the timer on the screen.
2.	A `KeyFrame` to call the `FlashcardTabWindowController#showFlashcardAns` method, which hides the Timer and flashes the answer of the flashcard for a set period of time.
3.	A `KeyFrame` is then added to the timeline to call the `FlashcardTabWindowController#resetViews` method, which in turn empties the qnsTextArea and ansTextArea. [TO BE REFORMATTED]

The following _figure_ shows the sequence diagram of when the command `timetrial cs2103t` is executed:

image::jrImages/TimeTrialSequenceDiagram.png[]

The following _figure_ is an activity diagram that summarizes the flow of events when a user attempts to start a time trial as described above:

image::jrImages/TimeTrialActivityDiagram.png[]

==== Design Considerations
===== Aspect: How the timetrial is implemented

* **Alternative 1 (current choice):** 1.	Using the `TimeLine` class to set the timer
object.
** Pros: Tidier and easier to understand.
** Cons: Have to read up on the API and learn about the relevant classes such as `KeyFrame` and `KeyValue`
* **Alternative 2:** Looping `Thread.sleep()` to set the timer
** Pros: Easier to implement
** Cons: Code will be messier and harder to read

===== Aspect: How to continue the time trial

* **Alternative 1 (current choice): Each flashcard and its’ respective answer is displayed for a set period of time before the next flashcard**
** Pros: Easier to implement
** Cons: Inflexible as user can only view the answer for a set amount of time
* **Alternative 2:** Allowing users to input commands to display the flashcard answer / move on to the next flashcard
** Pros: Better flow of time trial feature and improved user experience
** Cons: Hard to implement

==== [Proposed] Future improvements
** Allowing users to set their own time limit for each flashcard in the time trial mode
*** Command will be inputted to set the duration of the timer for each flashcard
** Allowing users to decide when to move on to the next flashcard
*** Question will still be shown for a fixed period of time, but a command will be required to move on to the next flashcard instead of just flashing the answer for a set amount of time

=== Remind Feature

[NOTE]
====
For this section, a _due flashcard_ refers to a flashcard that is due for revision today.
In other words, the current date (according to the user's system date) matches the date the
flashcard was next supposed to be viewed for optimum revision. Similarly, an _overdue flashcard_
refers to a flashcard whose view date for optimum revision was _before_ the current date. Further
details on how the optimum revision date is calculated is provided in this section!
====

This feature aims to help the user stay on track with the user's revision schedule through two
other sub-features. The first sub-feature is the `remind` command which helps the user
keep track of which flashcards are due (or overdue) for revision. The second sub-feature is
integrated with the `exit` command, and automatically asks the user for confirmation if they
wish to exit StudyBuddyPro if the user still has due or overdue flashcards left for revision.
An activity diagram summarizing how the remind feature works can be found below.

{To be completed soon}

image:: to be added + caption

==== Implementation of `remind` command

[IMPORTANT]
The following commands assume that the user is in the _flashcard_ mode.

The  remind feature is facilitated by ``

image::remindDiagrams/RemindFeatureRelevantClassDiagram.png[]

==== Design Considerations
===== Aspect: Implementation of utility attributes or classes to keep track of number of times a `Flashcard` object was
viewed.

* **Alternative 1 (current choice):** Design a new `ViewCount` class and make a `Flashcard` object store a `ViewCount`
object.
** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons:
* **Alternative 2:** Use an integer attribute field in `Flashcard` object
** Pros: Easier to maintain: The addition of a new class increases overall coupling compared to adding a single new
attribute.
** Cons: Bad OOP practice and makes it difficult to implement future changes

===== Aspect:

* **Alternative 1 (current choice):**
** Pros:
** Cons:
* **Alternative 2:**
** Pros:
** Cons:

==== [Proposed] Future improvements
** Improved formula for reminding
*** Take into account other factors such as user confidence level or number of times flashcard was answered correctly
or incorrectly to create a more dynamic reminding schedule.

** Link to `exit` command
*** Checks if the user viewed all flashcards to be revised on the day.
*** If some of the relevant flashcards were not viewed, reminds user about remaining flashcards and stalls
application exit.
*** User can either go back into StudyBuddyPro and view the relevant flashcards or supply an `exit` command again to
close the application.

** More statistics for motivation
*** Tracks how often user viewed flashcards on time and how many flashcards users missed viewing on the relevant
deadline.

==== Implementation of `exit` command
// end::remind[]

=== Add Tags Within Notes feature

`Notes` are used in the creation of `CheatSheet` objects as well as in general use of StudyBuddyPro. This Add Tags
Within Notes feature allows for the addition of tags within the content of the `Note`, to allow more precise
highlighting and tagging of information.

[IMPORTANT]
All the operations assume that the user is in the _notes_ mode.

==== Design Implementation of Notes

`Notes` contain a `Title` and a `Content`, with optional `Tags` and `NoteFragments`, as shown in the diagram below:

image::samDiagrams/NoteModelClassDiagram.png[]

`Notes` are `StudyBuddyItems`, and can contain any number of `NoteFragments`. `NoteFragment` objects are used to
represent the specific areas within a `Note` that have been tagged. Each tag within a `Note` is referred to as a *note
fragment tag* (which is represented by a `NoteFragment` object).

NOTE: Note fragment tags should not be confused with `Tags`.

`NoteFragments` contain:

** A `Title` that is the same as their parent `Note`
** A `Content` that is a substring of their parent `Note`
** Any indicated `Tags` that are independent of their parent `Note`

`NoteFragments` are viewed or used in the following situations:

** Viewable through the `filter` and `filterall` commands
** Usable through `add` commands in _cheatsheet_ mode (see Section 4.4)

==== Usages of Notes

`Notes` can be used to:

** Store information under a title
** Categorize information via the use of `Tags`
** Provide information to `CheatSheets` for collation

`Notes` can currently be:

** Added to `StudyBuddyBook`
** Deleted from `StudyBuddyBook`
** Viewed raw or cleaned from `StudyBuddyBook`
** Viewed using `filter` from `StudyBuddyBook`

==== Design Implementation of the Add Tags Within Notes feature

The Add Tags Within Notes feature was implemented in the following way:

** Creation of a `NoteFragment` class that represents one tag within a `Note`
** Have each `Note` contain any number of `NoteFragments` in a list
** Upon addition of a `Note`, parse its `Content` to check for any note fragment tags within it
** Create any required `NoteFragment` objects and add them to the list in their parent `Note`
** Since `NoteFragments` are contained within `Notes`, when a `Note` is deleted, its `NoteFragments` will be deleted as well.

There are four main methods that involve `NoteFragments`. They are listed below:

** `NoteFeatureUtil#parseNoteFragmentsFromNote()`: Used by `Note` to create `NoteFragments`.
** `ModelManager#collectTaggedItems()`: Used in the `filterall` command.
** `ModelManager#collectTaggedNotes()`: Used in the _notes_ `filter` command.
** `AddCheatSheetCommand#getRelevantContents()`: Used to generate `CheatSheets`.

Out of these four methods, only `NoteFeatureUtil#parseNoteFragmentsFromNote()` is aware of the `NoteFragment` class.
The other three methods are only aware of the `Note` class.

The implementation of these four methods is shown below:

===== Implementation of `NoteFeatureUtil#parseNoteFragmentsFromNote()`:

The method of parsing `Content` in `NoteFeatureUtil#parseNoteFragmentsFromNote()` relies on the use of `Prefixes`
around each note fragment tag. Each note fragment tag is specified with a start ("/\*") and end ("*/") marker, and
its `Content` and `Tags` are also represented with the `Prefixes` 'C/' and 'TAG/'.

Example usage:

```
add t/About Notes c/Notes can be /* C/highlighted TAG/highlight TAG/important */ if needed. tag/about
```

[NOTE]
'C/' and 'TAG/' have to be used instead of the default 'c/' and 'tag/' because otherwise the note fragment tag would
raise an error (since only one 'c/' tag is allowed per command).

Expected output:

```
New note added:
    Title: About Notes
    Content: Notes can be /* C/highlighted TAG/highlight TAG/important */ if needed.
    Tags: [about]

Note fragment tags detected:
    Title: About Notes
    Content: highlighted
    Tags: [important][highlight]
```

A `Note` has been added with the `Content` of "Notes can be highlighted if needed.", and a note fragment tag with
`Content` "highlighted" and two `Tags` "cs2100" and "important". Despite this, the `Note` itself is instead tagged
with the `Tag` "about".

When an `add` command is made:

** Only the `Prefixes` 't/', 'c/', and 'tag/' are identified and parsed.
** A `Note` is then created with the desired `Title`, `Content`, and `Tags`.
** After creation, the `Content` of the `Note` is parsed immediately for the `Prefixes` '/\*', '*/', 'C/', and 'TAG/'
.
** All four `Prefixes` must be present for the note fragment tag to be considered valid. Otherwise, an exception is
thrown.

The sequence diagram below describes the process of adding a new note that contains a note fragment tag:

<INSERT SEQUENCE DIAGRAM HERE, and refer to it below>

===== Implementation of `NoteFragments` in `list` command:

When `Notes` are listed, `NoteFragments` do not appear in the list of resulting `Notes`. This is because the
`ListCommand#execute()` method uses `ModelManager#updatedFilteredNoteList()`, which does not check for any
`NoteFragments` within `Notes`. This is illustrated in the <WHAT KIND OF> diagram below:

<SOME DIAGRAM SHOWING CALLING OF LISTCOMMAND FOR NOTE - but is this necessary? Would need to refer to it after the text>

This decision is made because the `list` command already lists all `Notes`, and therefore it would be unnecessary to
also list all `NoteFragments`, as `NoteFragments` form a subset of `Notes`.

===== Implementation of `NoteFragments` in `filter` command:

When `Notes` are filtered, the method `ModelManager#collectTaggedNotes()` is used, which checks for any valid tags in
`NoteFragments` within the `Note` as it checks each `Note`.

However, `ModelManager` uses the method `Note#getFilteredNoteFragments()` to achieve this, and therefore is not
aware of the existence of `NoteFragments`. This is illustrated in the <WHAT KIND OF> diagram below:

<SOME DIAGRAM SHOWING CALLING OF FILTERCOMMAND FOR NOTE - but is this necessary? Would need to refer to it after the
text>

This diagram can be contrasted with the <WHICH NUMBER?> diagram above, which uses a different method <DESCRIBE> that
does not account for `NoteFragments`.

The separation between `Notes` and `NoteFragments` in the `filter` command allows for more finely-tuned viewing of
specific tagged details. For instance:

** A small portion of a long `Note` can be tagged out as 'important'.
** Different parts of the same `Note` can be given different `Tags` like 'CS2103T' or 'CS2100', even as the entire
`Note` is tagged under a larger category like 'CS'.

===== Implementation of `NoteFragments` in `filterall` command:

When all `StudyBuddyItems` are filtered, the method `ModeManager#collectTaggedItems()` is used, which performs a
similar task to `ModelManager#collectTaggedNotes()`, but also collects `Flashcard` and `CheatSheet` objects as well.
The reasoning for this decision is similar to that in the `filter` command.

===== Implementation of `NoteFragments` in `add` command in `CheatSheets`:

When a `CheatSheet` is created, the method `AddCheatSheetCommand#getRelevantContent()` is used to filter out all
`Notes` and `NoteFragments` that contain the specified `Tags`. Again, `AddCheatSheetCommand` uses the method
`Note#getFilteredNoteFragments()` to obtain the filtered list of `NoteFragments`, and is therefore unaware of the
existence of `NoteFragment`.

Since the `Tags` stored in `Notes` and `NoteFragments` are independent of each other, they are filtered in the same
way as in the `filter` command. As a result, it is possible for a `NoteFragment` to be included in a `CheatSheet`
even when its parent `Note` is not.

==== Design Considerations of the Add Tags Within Notes feature

===== Aspect: Container location for `NoteFragment`

** Alternative 1 (current choice): Each `Note` contains a `List<NoteFragment>`:
*** Pros: Much easier maintenance, since `NoteFragments` are automatically deleted with the deletion of their parent
`Note`.
*** Cons: O(n^2^) search time for `filter` commands, as all `NoteFragments` in each `Note` in the `UniqueNoteList`
must be searched through to filter them out.

** Alternative 2: Separate `UniqueNoteFragmentList` from `UniqueNoteList`:
*** Pros: O(n) search time for `filter` commands, as the `UniqueNoteFragmentList` exists separately from the
`UniqueNoteList`.
*** Cons: Difficult to maintain; deletion of a parent Note requires searching the `UniqueNoteFragmentList` for any
child `NoteFragments` to delete as well.

==== Usages of the Add Tags Within Notes feature

** Use in `filter` and `filterall` to make the GUI less cluttered
** Use in `filter` to highlight specific sections of `Notes`
** Use in `add` for `CheatSheets` for more parsimonious usage of space

==== (Proposed) Future Improvements for v2.0

===== `edit` command for `Notes`

This feature will allow for users to edit their `Notes`, by specifying a new `Title`, `Content`, or `Tags`.

===== (Proposed) Implementation

** Expected inputs:
*** The original `Title` of the `Note` to be edited
*** One or more fields that the user wants to edit
** Create an `EditCommandParser` to parse the input command using `ArgumentTokenizer`
** Create an `EditCommand` which contains `EditCommand#execute()`
*** This method creates a new `Note` which contains all old fields, then replaces any old field with a new field, if
it is made available

Example usage:

    edit Old Title t/New Title

This would result in the `Note` which was originally called 'Old Title' having its `Title` changed to 'New Title'.
Since no two `Notes` are allowed to have the same `Title`, it is a unique identifier of the `Note` to be edited.

===== Design Considerations

====== Aspect: Method of editing

** Alternative 1: Create a new `Note` object
*** Pros: Is more defensive, since only a shallow copy of the `Note` object is returned.
*** Cons: Longer command run time, as a new `Note` object needs to be created first, and then edited.

** Alternative 2: Edit the exiting `Note` object
*** Pros: Command will run faster, since no new `Note` object needs to be created.
*** Cons: Is not defensively programmed, as `Notes` should be immutable.

== Documentation

Please do refer to the guide <<Documentation#, here>> for more information about this section!

== Testing

Please do refer to the guide <<Testing#, here>> for more information about this section!

== Dev Ops

Please do refer to the guide <<DevOps#, here>> for more information about this section!

== Appendixes

The following sections will be titled as '_Appendix_' followed by an alphabet in alphabetical order to denote the different appendixes.
The following is an example of an appendix heading.

*Appendix Z: ABC*

- Alphabet 'Z' indicates its placing in the order of appendixes
- Phrase 'ABC' indicates the title of the appendix

[appendix]
== Product Scope

*Target user profile*:

* is a Computer Science major student in NUS
* is a visual learner that benefits from using flashcards
* can benefit from better organization of notes
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: integrate flashcards and note compilers for CS students better than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *` |user |have as much information on hand as possible |get all the information I have collected and tagged as part of my revision and ensure that I have all the necessary information at hand.

|`* * *` |user |save time in creating cheatsheet | spend more time on revision

|`* * *` |user |tailor the information I have in my cheatsheet |choose which types of tags I want to include in my cheatsheet.

|`* * *` |user |familiarise with some common programs from the pre-set flashcards in the question bank |learn more useful tips and snippets of information

|`* * *` |user |quickly store tutorial questions for revision |just store a screenshot of the question for future reference

|`* * *` |user |lighten the weight of my bag |cure my back pain from carrying a heavy bag and still store my notes conveniently.

|`* * *` |user |find my notes efficiently for reference |write as much notes as possible during studies without worries

|`* * *` |user who constantly misplace notes |keep myself more organized |effectively see what notes are missing

|`* * *` |user |sort and skim through long lists of notes quickly |take notes during class without missing out important pointers

|`* * *` |user |take charge of my learning by having multiple “filters” or “levels” to my learning |be a proactive learner

|`* * *` |user who is forgetful |practice spaced retention |better memorize and recall the topics

|`* * *` |user |better understand or memorize the topics |improve my results

|`* * *` |university educator teaching multiple modules |easily categorize and organize the notes I create for my students |easily search by the tags for relevant notes

|`* *` |user |make cheatsheets from exams |organize and collate the best pointers to be made into a cheatsheet

|`* *` |user |creatively create and implement notes |be more effective with my studies

|`* *` |user |not take break for too long |be effective with my revision using the pomodoro technique

|`* *` |user |have suggestions on what to do during breaks | be more productive and on-track with tasks

|`* *` |user |make sure that my notes doesn’t miss out important points |collate and compare my notes with my friends’ efficiently

|`* *` |user |be reminded at appropriate times to revise my work |revise regularly and consistently

|`* *` |user |disseminate information efficiently |save the work amongst different teammates

|`* *` |user |better understand or memorize the topics |improve my results

|`* *` |user |connect different parts of questions together | easily link concepts together

|`* *` |user |share notes with my friends and for them to share notes with me, for ease of discussion |be able to study with others

|`* *` |user |answer the questions within a certain time frame |boost my confidence and proficiency in a subject

|`* *` |user |keep track of the harder questions |revise more effectively

|`* *` |university educator |keep track of my students' progress and evaluate who are the stronger/weaker students so they can help each other |help my students do well in their studies

|`* *` |university educator |distribute the flashcards I create to my students so they can use them to practice |help my students better memorise and recall my class content

|`* *` |university educator |give my students quizzes during lecture using the flashcards | make sure that they will not fall asleep during lecture.

|`*` |user |download flashcards from online sources |save time for other revisions

|`*` |user |create notes without papers | save the earth

|=======================================================================

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `StudyBuddyPro` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== *User story 1:*
As a student who is busy with revision and has no time to create a cheatsheet, the cheatsheet
generation feature will help me save time on creating cheatsheets and let me spend more time on revision.

[discrete]
=== Use case: UC01 – Create a cheatsheet

Preconditions: StuddyBuddy application is opened

*MSS*

1.	User navigates to cheetsheat section.

2.	User chooses to create new cheatsheet.

3.	StuddyBuddy asks user for new cheatsheet’s title.

4.	User inputs new cheatsheet’s title.

5.	StuddyBuddy asks user for new cheatsheet’s module.

6.	User inputs new cheatsheet’s module.

7.	StuddyBuddy asks for new cheatsheet’s tags.

8.	User inputs new cheatsheet’s tags.
+
Use case ends

[discrete]
=== Use case: UC02 – List cheatsheets

Preconditions: StuddyBuddy application is opened

*MSS*

1.	User navigates to cheetsheat section.

2.	User chooses to list all cheatsheet.

3.	StudyBuddyPro displays all cheatsheets.
+
Use case ends.

[discrete]
=== Use case: UC03 – Edit a cheatsheet

Preconditions: StudyBuddyPro application is opened, User knows cheatsheet ID

*MSS*

1.	User navigates to cheetsheet section.

2.	User chooses to edit cheatsheet.

3.	StudyBuddyPro asks for cheatsheet ID for cheatsheet to be edited.

4.	User inputs cheatsheet ID.

5.	StudyBuddyPro asks for parameters to be edited.

6.	User inputs perimeters to be edited.

7.	StudyBuddyPro displays edited cheatsheet.
+
Use case ends.

[discrete]
=== Use case: UC04 – View a cheatsheet

Preconditions: StudyBuddyPro application is opened, User knows cheatsheet ID

*MSS*

1.	User navigates to cheetsheat section.

2.	User chooses to view cheatsheet.

3.	StudyBuddyPro asks for cheatsheet ID for cheatsheet to be viewed.

4.	User inputs cheatsheet ID.

5.	StudyBuddyPro displays cheatsheet.
+
Use case ends.

=== Use case: User story 1

*MSS*

1.	User _creates cheatsheet (UC01)_.

2.	User _views cheatsheet (UC04)_.
+
Use case ends.

*Extensions*

* 2a. User chooses to edit cheatsheet.
+
2a1. User _edits cheatsheet (UC03)_.

{Fix indent}

+
Use case ends.

[discrete]
=== User story 2:
As a student who finds it very cumbersome to store tutorial questions that I would like to revise, I can make use of the flashcard function to just store a screenshot of the question for future reference.

[discrete]
=== Use case: UC05 – Create a flashcard from image
Software system: StudyBuddyPro, OS

Preconditions: StudyBuddyPro application is opened

*MSS*

1.	User finds a tutorial question he/she would like to revise.

2.	User takes screenshot of tutorial question.

3.	OS asks user where screenshot should be saved.

4.	User saves screenshot in designated StudyBuddyPro image folder with custom name.

5.	User opens StudyBuddyPro application.

6.	User navigates to flashcard section.

7.	User chooses to create new flashcard from image source.

8.	StudyBuddyPro asks user for file name.

9.	User inputs file name.

10.	StudyBuddyPro asks user for flashcard’s answer.

11.	User inputs flashcard’s answer.

12.	StudyBuddyPro asks user for flashcard’s title.

13.	User inputs flashcard’s title.

14.	StudyBuddyPro asks user for flashcard’s module.

15.	User inputs flashcard’s module.

16.	StudyBuddyPro displays created flashcard.
+
Use case ends.

*Extensions*

* 15a. User wants to input additional flashcard hint.

15a1. User inputs flashcard’s hint.

{Todo markup indent}

+
Use case resumes from step 16.

* 15b. User wants to input additional flashcard tags.

15a2. User inputs flashcard’s tags.

{Todo markup indent}

+
Use case resumes from step 16.

* 15c. User wants to input additional hint and tags.

15c1. User inputs flashcard’s hint.

15c2. User inputs flashcard’s tags.

{Todo markup indent}

+
Use case resumes from step 16.

[discrete]
=== Use case: UC06 – Start <<time-trial,time trial>>

*MSS*

1.	User navigates to flashcard section.

2.	User chooses to start time trial.

3.	StudyBuddyPro asks user for time per flashcard.

4.	User inputs time per flashcard.

5.	StudyBuddyPro asks user for tags to select flashcards for inclusion.

6.	User inputs tags.

7.	StudyBuddyPro starts time trial with specified parameters.
+
Use case ends.

[discrete]
=== Use case: User story 2

*MSS*

1.	User _creates flashcards from image (UC05)_ with tag “tutorial questions”.

2.	User _starts time trial (UC06)_ with tag “tutorial questions”.
+
Use case ends.

{Todo delete later}

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. StudyBuddyBook shows an error message.
+
Use case resumes at step 2.

_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  A flashcard cannot have more than 10 tags.
.  The product is not required to confirm if the user has answered the flashcard correctly. Instead, the product lets the user checks the answer and determine himself/herself if he/she has answered it correctly.
.  The in-built flashcard library is expected to be updated annually, to follow the curriculum of NUS computing modules.
.  The command-line syntax should prioritise user-friendliness.

_{More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[flash-card]] FlashCard::
A titled digital 'card' that contains a question (image or text), answer, as well as it's relevant tags.

[[cheat-sheet]] Cheatsheet::
A document that contains the notes the user has specified during creation

[[time-trial]] Time-Trial::
A mode of answering flashcards in which you must provide the answer within a designated time period.


[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

    {To be edited}

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

=== Remind feature

[TIP]
====
Refer to the note at the start of the
https://github.com/AY1920S1-CS2103T-W13-3/main/blob/master/docs/DeveloperGuide.adoc#46-remind-feature[Remind feature]
section for an explanation of the terms "due flashcards" and "overdue flashcards" used in
this section.
====

Testing this section may require the user to switch their system date. A quick guide on how this
can be done for the Windows 10 operating system can be found
https://kb.wisc.edu/helpdesk/79027[here] while one for Mac can be found
https://www.lifewire.com/manually-change-the-date-and-time-on-mac-2378143[here]. The process
should be similar for different versions of the operating systems.

. Testing `remind` command

* Test case 1

.. Prerequisites

... Currently in flashcard mode with Flashcard icon highlighted.

... There are no due or overdue flashcards.

.. Test command: `remind`

.. Expected: Feedback box outputs message:

    Well done - No due or overdue flashcards!

* Test case 2

.. Prerequisites

... Currently in notes or cheatsheet mode with the respective icon highlighted.

.. Test command: `remind`

.. Expected: Feedback box outputs message:

    Unknown command

* Test case 3

.. Prerequisites

... Currently in flashcard mode with the Flashcard icon highlighted.

... There are due flashcards. This can be simulated by adding a flashcard with the `add`
command and then changing the system date to the next day.

.. Test command: `remind`

.. Expected: Feedback box outputs message:

    Here are the flashcards due today:
    1. [FLASHCARD TITLE] - [FLASHCARD ANSWER]"

* Test case 4

.. Prerequisites

... Currently in flashcard mode with the Flashcard icon highlighted.

... There are overdue flashcards. This can be simulated by adding a flashcard with the `add`
command and then changing the system date to 2 days later.

.. Test command: `remind`

.. Expected: Feedback box outputs message:

    Here are your overdue flashcards:
    1. [FLASHCARD TITLE] - [FLASHCARD ANSWER] (Was due on YYYY-MM-DD)"

* Test case 5

.. Prerequisites

... Currently in flashcard mode with the Flashcard icon highlighted.

... There are overdue flashcards but no due flashcards. This can be simulated by the following
steps:

.... Add a flashcard (Called flashcard A) with the `add` command.

.... Add a flashcard (Called flashcard B) with the `add` command.

.... Switch the system date to 2 days later. Both flashcards A and B are now overdue. This
can be verified by using the `remind` command at this stage.

.... View flashcard A using the `view 1` command and then show its answer with the `show` command.
This means flahscard A is no longer overdue. Now there are no due flashcards today and one
overdue flashcard (flashcard B).

.. Test command: `remind`

.. Expected: Feedback box outputs message:

    Here are your overdue flashcards:
    1. [FLASHCARD TITLE] - [FLASHCARD ANSWER] (Was due on [YYYY-MM-DD])

.. Note how only the overdue flashcard B was shown while no explicit output was provided
to indicate there were no other flashcards due today. This is an intended behaviour to
avoid clutter.

* Test case 6

.. Prerequisites

... Currently in flashcard mode with the Flashcard icon highlighted.

... There are both due and overdue flashcards. This can be simulated by the following
steps:

.... Add a flashcard (Called flashcard A) with the `add` command.

.... Switch the system date to 1 day later. Flashcard A is now due. This
can be verified by using the `remind` command at this stage.

.... Add a flashcard (Called flashcard B) with the `add` command.

.... Switch the system date to 1 day later. Flashcard A is now overdue while flashcard B
is due.

.. Test command: `remind`

.. Expected: Feedback box outputs message:

    Here are the flashcards due today:
    1. [FLASHCARD TITLE] - [FLASHCARD ANSWER]
    Here are your overdue flashcards:
    1. [FLASHCARD TITLE] - [FLASHCARD ANSWER] (Was due on [YYYY-MM-DD])

.. Note how flashcard B is listed under due today while flashcard A is listed under overdue
flashcards.

. Testing `exit` command

* Test case 1

.. Prerequisites

... StudyBuddyPro just launched with no mode selected. GUI does not show any icon highlighted.

... There are due flashcards. Refer to
https://github.com/AY1920S1-CS2103T-W13-3/main/blob/master/docs/DeveloperGuide.adoc#g3-remind-feature[Remind command
manual testing], specifically test cases 3, for how this can be simulated.

.. Test command: `exit`

.. Expected: Feedback box outputs message:

    Are you sure you want to exit? You still have the following flashcards overdue or left to revise for today:
    Here are the flashcards due today:
    1. [FLASHCARD TITLE] - [FLASHCARD QUESTION]
    Type 'exit' again to exit the application!

.. Pressing kbd:[Enter] exits StudyBuddyPro. This also highlights how the this sub-feature
of the remind feature works regardless of which mode the user is in since `exit` is a global
command.

.. Alternatively, the user can switch back to flashcard mode using `switch fc`, view the
added flashcard and its answer using `view 1` and `show`, before using `exit` again. This time
StudyBuddyPro exits immediately since now there are no due or overdue flashcards.

* Test case 2

.. Prerequisites

... Currently in flashcard mode with the Flashcard icon highlighted.

... There 1 due and 1 overdue flashcard. Refer to
https://github.com/AY1920S1-CS2103T-W13-3/main/blob/master/docs/DeveloperGuide.adoc#g3-remind-feature[Remind command
manual testing], specifically test cases 6, for how this can be simulated.

.. Test command: `exit`

.. Expected: Feedback box outputs message:

    Are you sure you want to exit? You still have the following flashcards overdue or left to revise for today:
    Here are the flashcards due today:
    1. [FLASHCARD TITLE] - [FLASHCARD QUESTION]
    Here are your overdue flashcards:
    1. [FLASHCARD TITLE] - [FLASHCARD ANSWER] (Was due on [YYYY-MM-DD])
    Type 'exit' again to exit the application!

.. Enter another generic command e.g. `switch notes`. Now, entering the test command `exit`
will prompt the same feedback as shown above in part c. This highlights how entering another
valid command will refresh the "state" of the exit command which again requires a
double-confirmation before the user can exit StudyBuddyPro.

. Combination testing: `remind` and `exit` command with `timetrial`

* Test case 1

.. Prerequisites

... Currently in flashcard mode with the Flashcard icon highlighted.

... There 1 due and 1 overdue flashcard. Refer to
https://github.com/AY1920S1-CS2103T-W13-3/main/blob/master/docs/DeveloperGuide.adoc#g3-remind-feature[Remind command
manual testing], specifically test cases 6, for how this can be simulated. Ensure the flashcard
due today is tagged with the tag "pop". For example, the flashcard could be added with the command:
`add q/What is 1+1? a/2 t/Math Question 1 tag/pop`.

.. Test command: `remind`

.. Expected: Feedback box outputs message:

    Here are the flashcards due today:
    1. [FLASHCARD TITLE] - [FLASHCARD ANSWER]
    Here are your overdue flashcards:
    1. [FLASHCARD TITLE] - [FLASHCARD ANSWER] (Was due on [YYYY-MM-DD])

.. Start a timetrial with the flashcard that is due today i.e. tagged with "pop" using the
command  `timetrial pop`

.. Test command: `exit`

.. Expected: Feedback box outputs message:

    Are you sure you want to exit? You still have the following flashcards overdue or left to revise for today:
    Here are the flashcards due today:
    1. [FLASHCARD TITLE] - [FLASHCARD QUESTION]
    Type 'exit' again to exit the application!

.. This highlights how the flashcard that was due today (tagged with "pop") was updated
when it was viewed during the timetrial and was no longer considered due. Thus, when the user
tried to exit, only the one overdue flashcard which was still not viewed was flagged.
