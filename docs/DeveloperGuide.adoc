= TagLine - Developer Guide
:toclevels: 3
:sectnums:
:sectnumlevels: 3
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-F12-3/main/tree/master

By: `CS2103T-F12-03`      Since: `Oct 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/tagline/Main.java[`Main`] and link:{repoURL}/src/main/java/tagline/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `contact delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/tagline/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` which is made up of four parts, i.e. `StatusBarFooter`, `HelpWindow`, `ChatPane` and `ResultPane`. In particular,

*  The `ChatPane` manages text interaction with the user. It uses `CommandBox` to read commands and `DialogBox` to display commands and feedback.

.Structure of the Chat Pane sub-component
image::UiChatPaneClassDiagram.png[]

*  The `ResultPane` displays a relevant `ResultView` based on the command entered.

.Structure of the Result Pane sub-component
image::UiResultPaneClassDiagram.png[]

All these classes, including the `MainWindow` itself, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/tagline/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Displays feedback and updates the `ResultPane` using `CommandResult` in the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/tagline/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `TaglineParser` class to parse the user command.
.  The user command is passed to different command parser based on the command type. E.g. __"note delete 1"__ will be passed to `NoteCommandParser`
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a note).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

==== Contact Logic component
.Structure of the Contact Logic Component
image::ContactLogicClassDiagram.png[]

. `Contact Logic` is a sub-component of `Logic`.
. `TaglineParser` will pass a user input that can be classified as a contact command (i.e. has __"contact "__ prefix),
to the `ContactCommandParser` without including the __"contact"__ keyword, e.g. `TaglineParser` will only pass
__"create --n Bob"__ instead of __"contact create --n Bob"__.
. `ContactCommandParser` identifies the type of contact command and passes the argument string to the respective command
parser. For example, `ContactCommandParser` will pass __"--n Bob"__ to `CreateContactParser` if it receives
__"create --n Bob"__ as an input.
. This results in a `ContactCommand` object which is returned to the `LogicManager`.
. The command execution can affect the `ContactModel`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the
`execute("contact create --n Bob")` API call.

.Interactions Inside the Logic Component for the `contact create --n Bob` Command
image::ContactCreateSequenceDiagram.png[]

==== Note Logic component

[[fig-NoteLogicClassDiagram]]
.Structure of the Note Logic Component
image::NoteLogicClassDiagram.png[]

.  `Note Logic` is a sub-component of `Logic`.
.  It obtains the user command parsed by `TaglineParser` through the `NoteCommandParser` class.
.  The user command is passed to the respective command parser. E.g. __"note delete 1"__ will be passed to `DeleteNoteParser`.
.  This results in a `NoteCommand` object which is returned to the `LogicManager`.
.  The command execution can affect the `NoteModel` (e.g. adding a note).

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("note delete 1")` API call.

.Interactions Inside the Logic Component for the `note delete 1` Command
image::NoteDeleteSequenceDiagram.png[]

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/tagline/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* manages Address Book data through `ContactModel` sub-component.
* manages Note Book data through `NoteMode` sub-component.

[[Design-ContactModel]]
==== Contact Model component

.Structure of the Contact Model Component
image::ContactModelClassDiagram.png[Contact Model Diagram, 625, 500]

*API* : link:{repoURL}/src/main/java/tagline/model/contact/ContactModel.java[`ContactModel.java`]

The `ContactModel`,

* stores the Address Book data.
* exposes an unmodifiable `ObservableList<Contact>` which can be accessed from `Model` that can be 'observed' e.g. the
UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[[Design-NoteModel]]
==== Note Model component

.Structure of the Note Model Component
image::NoteModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/tagline/model/note/NoteModel.java[`NoteModel.java`]

The `NoteModel`,

* stores the Note Book data.
* exposes an unmodifiable `ObservableList<Note>` which can be accessed from `Model` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As an additional feature to be implemented in the future, we can store a `Tag` list in `Note`. This would allow `Note` to be able to be better categorized.

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/tagline/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.

[[Design-ContactStorage]]
==== Contact Storage component

.Structure of the Contact Storage Component
image::ContactStorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/tagline/storage/note/ContactBookStorage.java[`ContactBookStorage.java`]

The `ContactStorage` component,

* can save the Address Book data in json format and read it back.

[[Design-NoteStorage]]
==== Note Storage component

.Structure of the Note Storage Component
image::NoteStorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/tagline/storage/note/NoteBookStorage.java[`NoteBookStorage.java`]

The `NoteStorage` component,

* can save `Note` objects in json format and read it back.
* can save `NoteIdCounter` state in json format and read it back.
* can save the Note Book data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `tagline.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== [Proposed] Chatbot prompting feature

==== Description

When the user enters an incomplete command, the command could be missing only a few compulsory fields. Instead of forcing the user to edit the command entirely, TagLine will prompt the user for further details instead.

At this point, the user may abort the command or provide the requested details. When all details are provided, the command is executed.

==== Proposed Implementation

The prompting mechanism uses `Prompt` objects to represent individual queries for additional information. A list of `Prompt` objects is used to pass information between the `Logic` and `Ui` components. `Prompt` implements the following operations:

`Logic` side:

* `Prompt#setPrefix()` -- Sets the prefix of the queried data
* `Prompt#setQuestion()` -- Sets the prompt to be displayed to the user
* `Prompt#getResponse()` -- Gets the prompt response from the user

`Ui` side:

* `Prompt#getQuestion()` -- Gets the prompt to be displayed to the user
* `Prompt#setResponse()` -- Sets the response from the user

Given below is an example scenario where the user command has missing compulsory fields.

Step 1: The `Ui` passes the user's command to `Logic`, which finds one or more missing compulsory fields. For each missing field, it creates a new `Prompt` object with a question. Then it throws a `ParseException` containing the list of `Prompt` objects.

image::UserPromptSequenceDiagramStep1.png[]

Step 2: The `Ui` receives the list of `Prompt` objects. For each `Prompt`, it retrieves the question and obtains the corresponding user feedback.

image::UserPromptSequenceDiagramStep2.png[]

Step 3: The `Ui` passes the original command, together with the processed `Prompt` objects, back to `Logic`. `Logic` then executes the corrected command.

image::UserPromptSequenceDiagramStep3.png[]

The user can also abort the command by entering a special string. In this case, the `Ui` will discard the original command and continue to receive further user commands.

==== Design Considerations

===== Aspect: Command correction method

* **Alternative 1**: The `Ui` updates the command with the user's responses by adding the new data to the command string.
** Pros: No need to overload `Logic#execute()` and `Parser#parse()` methods
** Cons: Requires `Ui` to know where to insert preambles, and increases coupling between `Ui` and `Logic` components (as `Ui` now needs to know and follow the command format)
* **Alternative 2** (chosen): The `LogicManager` updates the command with the user's responses by adding the new data to the command string.
** Pros: No need to overload `Parser#parse()` method
** Cons: Requires all commands to follow the same general format
* **Alternative 3**: The `Parser` handles the `Prompt` objects when parsing the command
** Pros: Easily handles preambles and allows greater extensibility of the prompt feature, e.g. can have the user fix incorrect commands
** Cons: Requires changing every `Parser` class, decreases maintainability in the long run

=== [Proposed] Group Contacts feature
==== Proposed Implementation

The grouping feature is facilitated by `GroupBook` an additional Model component in addition to the current `AddressBook`.
It extends the functionality of `AddressBook` by providing a way to group contacts together into unique `Group` classes
identified by their `GroupName`. This allows users to form more natural associations of
contacts such as "BTS-members". Identifying which contacts are group members of a `Group` is done by
storing a record of their `ContactId` in the `Group`.
Additionally, `GroupManager` extends Tagline with the following operations:

* `GroupManager#getGroupBook()` -- Retrieves a view only version of the groups for storing data after app quits.
* `GroupManager#deleteGroup()` -- Deletes a group from the list of groups currently available.
* `GroupManager#addGroup()` -- Adds a group to the list of groups currently available.
* `GroupManager#setGroup()` -- Replaces a group in the list of groups with another group.
* `GroupManager#getFilteredGroupList()` -- Returns a view only list of groups containing a subset of available Groups.
* `GroupManager#updateFilteredGroupList()` -- Specifies which groups will be retrieved by `GroupManager#getFilteredGroupList()`.

The above operations are exposed in the `Model` interface by their respective method names.

* `GroupCommand#findOneGroup()` -- Retrieves one Group with name matching the exact provided String.
* `GroupCommand#verifyMemberIdWithModel()` -- Compares members currently in a group with contacts in `AddressBook` and returns only those found in `AddressBook`.
* `GroupCommand#setDifference()` -- Used to get contactids specified which do not exist in `AddressBook`.

These above are static utility functions which form the underlying structure of how a `GroupCommand` works.

Given below is an example usage scenario on how a typical lifecycle of a `Group` behaves at each step.
With emphasis on showing the effects of `DeleteCommand` as an example of a command from `ContactCommand`
would interact with `GroupCommand` and `GroupModel` state.


Step 1. The user initially has several contacts in `AddressBook`. +

.Simplified state of relevant Model components initially
image::GroupContactsState0.png[]


The `AddressBook` model state contains all the `Contact` class that exists in the App.
 Since no `Group` has been created yet, `GroupBook` model state is currently empty.
 All of the contacts found in `AddressBook` are displayed on the `UI` by default.


Step 2. Wishing to better organize her contacts into groups, the user executes `group create BTS` calling
 `CreateGroupCommand`. to create a new `Group` instance with no members. +

.State after Group "BTS" is created
image::GroupContactsState1.png[]

The `GroupBook` model state now contains a `Group` instance for "BTS" with no members
 recorded as memberIds.
Any command regarding `Group` would prompt the `UI` to display the contacts in the group.
 A group with no members would cause the `UI` to be empty. As there are no contacts in the group.
 While a group with members in it would cause `UI` to display all the contacts belonging
 to that group.


Step 3. The user then executes `group add BTS --i 00001 --i 00002 --i 0013 --i 0004`
 calling the `addMembersToGroupCommand` to add several contacts to the group. Only the String
 representation of the `ContactId` will be stored in the `Group`. +

.State after four contacts are added into Group "BTS"
image::GroupContactsState2.png[]

`Group` "BTS" now has members in it and the `UI` would display all the contacts found in the
 group.


Step 4. The user realizes she has made a mistake adding a wrong contact and in a fit of rage
 chooses to delete the contact instead of merely removing the contact from the Group.
 Executing `contact delete --i 00013`
 which then deletes the `Contact` with contactId of 00013.
 However, this does not remove the contact's id from
 the memberId attribute in the `Group` the contact was in. This step does not involve `GroupModel` in any way. +

.State after contact with contactId = 00013 is deleted
image::GroupContactsState3.png[]

Deleting a `Contact` would cause it to be removed from `AddressBook` model state and the `Contact`
 no longer exists. While the `UI` display no longer shows contact of 00013, it is still recorded as a member in
 `GroupBook` model state. The updating of `GroupBook` model state is deferred.


Step 5. The user then executes `group add BTS --i 00003` to add the correct contact as a member on the `Group`
 and view the `Contact` profiles.
 This calls `AddMemberToGroupCommand` which then updates the `Group` ensuring that all memberIds correspond to an existing
 `ContactId` found in `AddressBook`. The contacts of the group are also displayed to the user.  +

.State after user views contacts of Group "BTS"
image::GroupContactsState4.png[]

Here, the `GroupBook` model state is updated and memberId of 00013 from the previous step is removed while `Contact`
 with contactId of 00003 is added into the `Group`. This change is also reflected in the `UI`.
Now all is as it should be in `Group` "BTS". +


The following sequence diagram summarizes what happens when a user executes a `FindGroupCommand` which
 which updates the `Group` similar to how `AddMemberToGroupCommand` does in the above example:

.Sequence diagram of executing `FindGroupCommand` to view contacts in a `Group`
image::GroupSequenceDiagram.png[]

==== Design Considerations

===== Aspect: How groups stores contacts

* **Alternative 1:** Stores `ContactId` class in a `Collection` in `Group`
** Pros: Easy to get `ContactId` from `Group` to retrieve `Contact` classes from `Addressbook`.
** Cons: Increases coupling to implementation of `Contact`. Storage and retrieval after reloading the app would also
 cause new instances of `ContactId` to be created when loading `Group` or would require more complicated
 loading of `Group` from storage having to happen after `AddressBook` is loaded and having to reference
 `Contact` classes to ensure the same `ContactId` class is referenced by both `Contact` and `Group` it is in.
* **Alternative 2 (current choice):** Stores `Collection` of Strings which are able to uniquely identify `Contact`.
** Pros: Group classes are less coupled to implementation of `Contact`. Simpler to load `Group` classes from storage.
 due to not needing to check and obtain a reference to `ContactId`. User input is also parsed as Strings.
** Cons: Deciding when to check if members are still part of a `Group` since it need not be done at loading time.
 While it is more flexible, can be a potential source of confusion as it may be possible to forget to update
 the members in `Group`.

// end::groupcontacts[]

=== [Proposed] Tagging feature
==== Description

The user can tag a note with many tags by using <<UserGuide#note-tag, `note tag`>> command.

==== Proposed Implementation

In order to add tagging feature we will need to take a look at two processes, which are the tag command creation and the
 execution of the command.

===== Creating Tag Command

We will use a TagParserUtil to create a tag from user input.

Given below is an example scenario when a user tag a note with 2 tags.

**Step 1:** The user command will be passed to `TaglineParser`, all the way to the `TagNoteParser`.

image::CreatingTagNoteCommand.png[]

**Step 2:** `NoteParserUtil` will be used to create a `noteId` object.

**Step 3:** Finally, `TagParserUtil` will be used to create `tag` objects. All of them will be aggregated inside a `tagList`.

This whole process has created a `TagNoteCommand` object from user input.

===== Executing Tag Command

Now, we will take a look on how we are executing the tagging command.

Given below is an example scenario when the tagging command gets executed.

**Step 1:** The `TagNoteCommand` will first exchange each tag with a tagId through model. Internally, model will have to
interact with TagManager which will find the tag or create it if it does not exist.

image::ExecutingTagNoteCommand.png[]

**Step 2:** The `TagNoteCommand` then interact with `NoteManager` in order to find the corresponding note.

**Step 3:** Finally, each `tagId` will be added to note through `NoteManager`.

This whole process has executed the `TagNoteCommand`.

=== [Proposed] Note filtering feature
==== Description

The user can filter notes by providing a filter in the <<UserGuide#note-list, `note list`>> command.

Types of filter:

* No prefix - filter by String keyword
* Prefix `#` - filter by hashtag
* Prefix `@` - filter by contact
* Prefix `%` - filter by group

==== Proposed Implementation

The note filter mechanism is facilitated by the `Filter` inner class in link:{repoURL}/src/main/java/tagline/logic/commands/note/ListNoteCommand.java[`ListNoteCommand`].
It contains a String filter value and the enum `FilterType`.

A `Filter` is generated by the `NoteFilterUtil` inner class in link:{repoURL}/src/main/java/tagline/logic/parser/note/ListNoteParser.java[`ListNoteParser`] and passed into `ListNoteCommand`.

===== Filter by String keyword

Filter by keyword also implements the  link:{repoURL}/src/main/java/tagline/model/note/NoteContainsKeywordsPredicate.java[`NoteContainsKeywordsPredicate`]. The `Predicate` is passed into `Model#updateFilteredNoteList()` to list only notes that contain the keywords.

Given below is an example scenario where the user enters a command to filter notes by keywords.

**Step 1:** The user command is passed through the `LogicManager` and a `ListNoteCommand` with the `Filter` containing the keywords and `FilterType.KEYWORD` is returned.

.Sequence diagram of parsing note filter user command to obtain a `ListNoteCommand`
image::FilterKeywordSequenceDiagram1.png[]

**Step 2:** The `ListNoteCommand` returned will be executed by the `LogicManager`. If a `Filter` exists and is of `FilterType.KEYWORD`, `ListNoteCommand#filterAndListByKeyword()` will be called.

.Sequence diagram of executing `ListNoteCommand` to update filtered note list by keyword in `Model`
image::FilterKeywordSequenceDiagram2.png[]

The method will create a `NoteContainsKeywordsPredicate` and update the list of notes to be displayed via `Model`.

image::FilterKeywordExample.png[]

===== Filter by Tag

Filter by `Tag` makes use of the `TagManager#findTag()` to obtain the `Tag` by passing in the `TagId`. It implements the `NoteContainsTagPredicate` which is passed into `Model#updateFilteredNoteList()` to list only notes that contain the tag.

Given below is an example scenario where the user enters a command to filter notes by tag.

**Step 1:** Similar to filtering by keyword, the user command is passed through the `LogicManager` and a `ListNoteCommand` with the `Filter` containing the keywords and `FilterType.TAG` is returned.

**Step 2:** The `ListNoteCommand` returned will be executed by the `LogicManager`. If a `Filter` exists and is of `FilterType.TAG`, `ListNoteCommand#filterAndListByTag()` will be called.

The method will create a `TagId` from the user input and obtain the `Tag` through the `TagManager#findTag()`. The `Tag obtained will be passed into the `NoteContainsTagPredicate`. The `Predicate` is then used to filter the list of notes via `Model`.

.Sequence diagram of executing `ListNoteCommand` to update filtered note list by `Tag` in `Model`
image::FilterTagSequenceDiagram.png[]

=== [Proposed] Undo/Redo feature
==== Proposed Implementation

The undo/redo mechanism is facilitated by `VersionedAddressBook`.
It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedAddressBook#commit()` -- Saves the current address book state in its history.
* `VersionedAddressBook#undo()` -- Restores the previous address book state from its history.
* `VersionedAddressBook#redo()` -- Restores a previously undone address book state from its history.

These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

image::UndoRedoState0.png[]

Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

image::UndoRedoState1.png[]

Step 3. The user executes `add n/David ...` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

image::UndoRedoState2.png[]

[NOTE]
If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

image::UndoRedoState3.png[]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial address book state, then there are no previous address book states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoSequenceDiagram.png[]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

The `redo` command does the opposite -- it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

[NOTE]
If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone address book states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

image::UndoRedoState4.png[]

Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.

image::UndoRedoState5.png[]

The following activity diagram summarizes what happens when a user executes a new command:

image::CommitActivityDiagram.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of address book states.
** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
// end::undoredo[]

// tag::dataencryption[]
=== [Proposed] Data Encryption

_{Explain here how the data encryption feature will be implemented}_

// end::dataencryption[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Our product is targeted at users who:*

* Need to manage a large variety of notes related to multiple categories
* Need to manage large numbers of team projects or relationships
* Want to keep their notes organized
* Prefer desktop applications over mobile applications
* Prefer typing commands over using graphical interfaces

*Value proposition*: TagLine manages notes faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="90%",cols="15%,<20%,<30%,<35%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |user |add a new contact |
|`* * *` |user |edit a contact |update outdated information
|`* * *` |user |delete a contact |remove entries that I no longer need
|`* * *` |user |find a contact by name |locate details of contacts without having to go through the entire list
|`* * *` |user |group my contacts |manage contacts for different occasions better
|`* * *` |user |view all contacts in a group |
|`* * *` |user |add new notes |
|`* * *` |user |edit a note |fix typos or incorrect details
|`* * *` |user |delete a note |clean up my app
|`* * *` |user |list all notes by chronological order |view most relevant notes first
|`* * *` |user |tag my notes |group related notes together
|`* * *` |user |view all notes according to tags |view only notes related to an issue
|`* * *` |user |view all notes related to a contact |discuss these notes with them when I meet them
|`* * *` |user |view all notes related to a group |
|`* *` |user |view all notes related to groups as well when querying for a person |view all information associated with that person at a glance
|`* *` |user with many friends with the same name |be able to differentiate them easily |locate a specific person
|`* *` |user |archive old notes |keep them while not cluttering my app page
|`* *` |user |export all my data and create a backup |keep my data somewhere safe
|`* *` |new user |get suggestions when typing commands |do not need to memorize commands
|`*` |user |embed links in my notes |directly access relevant webpages
|`*` |user |associate photos with notes |store and view related photos and notes together
|`*` |user |add text styles |personalize my entries
|`*` |user |colour entries with the same tag |organize my notes better
|`*` |user |prompted for correction when I make typos |fix my command without re-typing it entirely
|`*` |user |prompted for confirmation when I delete or edit notes or contacts |avoid making irreversible mistakes
|`*` |user |lock notes with authentication |keep my notes secure
|=======================================================================

[appendix]
== Use Cases

(For each of the use cases below, the *System* is `TagLine` and the *Actor* is the `user`, unless specified otherwise)

The use cases are divided into categories using the following naming convention:

*   *UCC* for contact-related use cases
*   *UCN* for note-related use cases
*   *UCE* for error handling use cases.

[discrete]
=== UCC01 Add person

*MSS*

1.  User requests to add a contact.
2.  TagLine adds the contact to the contact list.
+
Use case ends.

*Extensions*

[none]
* 1a. [underline]#UCE01 Invalid command syntax#
+
[none]
* 1b. [underline]#UCE02 Missing compulsory fields#

[discrete]
=== UCC02 Add group

*MSS*

1.  User requests to create a new group.
2.  TagLine creates the group.
+
Use case ends.

*Extensions*

[none]
* 1a. [underline]#UCE01 Invalid command syntax#
+
[none]
* 1b. [underline]#UCE02 Command with missing compulsory fields#
+
[none]
* 1c. User inputs a group with the same members as one that already exists.
+
[none]
** 1c1. TagLine adds the new group name as an alias to the currently existing group.
+
[none]
Use case ends.

[discrete]
=== UCN01 Add note

*MSS*

1.  User requests to add a new note.
2.  TagLine creates the note.
3.  TagLine displays the newly created note.
+
Use case ends.

*Extensions*

[none]
* 1a. [underline]#UCE01 Invalid command syntax#
+
[none]
* 1b. User does not include a tag for the note
+
[none]
** 1b1. TagLine prompts user if the user wants to add a tag.
** 1b2. User either adds a tag or declines.
+
[none]
Use case resumes at step 2.

[discrete]
=== UCN02 Add tag to note

*MSS*

1.  User requests to tag a currently existing note
2.  TagLine adds the tag to the note.
3.  TagLine displays the edited note.
+
Use case ends.

*Extensions*

[none]
* 1a. [underline]#UCE01 Invalid command syntax#
+
[none]
* 1b. [underline]#UCE03 Command with ambiguous field#

[discrete]
=== UCE01 Invalid command syntax

*MSS*

1.  User inputs an invalid command.
2.  TagLine requests correction from the user.
3.  User corrects the command.
4.  TagLine executes the command.
+
Use case ends.

*Extensions*

[none]
* 2a. User aborts the command.
+
[none]
** 2a1. TagLine confirms the abort.
+
[none]
Use case ends.

[discrete]
=== UCE02 Command with missing compulsory fields

*MSS*

1.  User inputs a command with missing compulsory fields.
2.  TagLine prompts user for a missing field value.
3.  User inputs the field value.
+
[none]
Until all missing field values are inputted.
4.  TagLine executes the command.
+
Use case ends.

*Extensions*

[none]
* 2a. User aborts the command.
+
[none]
** 2a1. TagLine confirms the abort.
+
[none]
Use case ends.

[discrete]
=== UCE03 Command with <<ambiguous-field,ambiguous field>>

*MSS*

1.  User inputs a command with an ambiguous field value (e.g. name).
2.  TagLine prompts user with a list of suggested values and their unique IDs.
3.  User inputs the ID.
4.  TagLine executes the command.
+
Use case ends.

*Extensions*

[none]
* 2a. User aborts the command.
+
[none]
** 2a1. TagLine confirms the abort.
+
[none]
Use case ends.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 contacts without a noticeable sluggishness in performance for typical usage.
.  Should be able to display large amounts of text quickly, i.e. up to 10MB of text data within 2 seconds
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Command syntax should not exceed 10 distinct terms, in order to avoid user confusion.

[appendix]
== Glossary

[[ambiguous-field]] Ambiguous field::
A field for a command that is not unique, e.g. many users can have the name John Doe

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others


[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
