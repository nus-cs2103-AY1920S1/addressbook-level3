= THRIFT - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-W12-2/main/tree/master

image::logo/logo.png[align="center"]

By: `Team THRIFT`      Since: `Sept 2019`      Licence: `MIT`

== Introduction
<<thrift, THRIFT>> is an application for money-conscious NUS students who wish to track their spending, in order to make better informed decisions when it comes to saving money.
It maintain records of your daily incoming and outgoing transactions and constantly keep track of the user's spending and income.
THRIFT is optimized for those who prefer to work with a Command Line Interface (CLI) while still enjoying the benefits of having a Graphical User Interface (GUI).
It is a simple, no-frills finance tracker made for the target user group.

=== Purpose

This developer guide aims to communicate to the developers working on THRIFT the design and architecture of the implementation.
It also includes non-technical details to give the developers an idea of the direction THRIFT intends to take on both current and future features.
A developer should be able to understand the design, architecture and goals of THRIFT after reading this guide.

=== Scope

This developer guide specifies the technical and non-technical details of THRIFT.
The technical aspects include the design and architecture while the non-technical aspects include the user stories, use cases and <<nfr, NFRs>>.

=== About the document
TIP: This symbol indicates a tip that you may find useful when enhancing THRIFT.

NOTE: This symbol indicates information that you may want to take note of when enhancing THRIFT.

WARNING: This symbol indicates information that you need to be cautious of when enhancing THRIFT.

[horizontal]
*add_expense n/Laksa v/4*:: Bold text indicates user input.

_/src/java/thrift/logic/Logic.java_:: Italic text indicates that it is a file/github path.

`currentMonth`:: Text with grey highlight (called a mark-up) indicates that it is a method/variable/parameter name.

`**THRIFT**`:: Bold text with mark-up indicates a class/package name.

`__Model.java__`:: Italic text with mark-up indicates a file name.

== Setting up

In this section, we will be introducing the way to set up THRIFT.

=== Prerequisites

. JDK 11 or above
. IntelliJ IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to *File* > *Settings* > *Plugins* to re-enable them.

=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click *File* > *Close Project* to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click *Configure* > *Project Defaults* > *Project Structure*
.. Click *New...* and find the directory of the JDK
. Click *Import Project*
. Locate the `__build.gradle__` file and select it. Click *OK*
. Click *Open as Project*
. Click *OK* to accept the default settings.

=== Verifying the setup

. Run the `*thrift.Main*` and try a few commands
. <<Testing,Run the tests>> to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to *File* > *Settings...* (Windows/Linux), or *IntelliJ IDEA* > *Preferences...* (macOS)
. Select *Editor* > *Code Style* > *Java*
. Click on the *Imports* tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to *999* to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is *import static all other imports*, *import java.\**, *import javax.**, *import org.\**, *import com.**, *import all other imports*. Add a *<blank line>* between each *import*

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, the documentation will still have the THRIFT branding and refer to the _AY1920S1-CS2103T-W12-2/main_ repo.

If you plan to develop this fork as a separate product (i.e. instead of contributing to _AY1920S1-CS2103T-W12-2/main_), you should do the following:

. Configure the <<Docs-SiteWideDocSettings, site-wide documentation settings>> in link:{repoURL}/build.gradle[`_build.gradle_`], such as the `site-name`, to suit your own project.

. Replace the URL in the attribute `repoURL` in link:{repoURL}/docs/DeveloperGuide.adoc[`_DeveloperGuide.adoc_`] and link:{repoURL}/docs/UserGuide.adoc[`_UserGuide.adoc_`] with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding, we recommend that you get some sense of the overall design by reading about <<Design-Architecture, THRIFT's architecture>>.

== Design

In this section, we will be introducing the individual components that combine together to form `**THRIFT**`. We will be including diagrams
drawn with the PlantUML software.

WARNING: There is a limitation with PlantUML sequence diagrams whereby the participation line of a member does not terminate after it is destroyed.

[[Design-Architecture]]
=== Architecture

.Architecture diagram
image::ArchitectureDiagram.png[]

The architecture diagram given above explains the high-level design of the application. We provide a quick overview of each component below.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`**Main**` has two classes called link:{repoURL}/src/main/java/thrift/Main.java[`**Main**`] and link:{repoURL}/src/main/java/thrift/MainApp.java[`**MainApp**`]. It is responsible for:

* At application launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,`**Commons**`>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `**LogsCenter**` : Used by many classes to write log messages to the application's log file.

The rest of the application consists of four components.

* <<Design-Ui,`**UI**`>>: Displays the UI of the application.
* <<Design-Logic,`**Logic**`>>: Executes the various commands.
* <<Design-Model,`**Model**`>>: Holds the data of the application in-memory.
* <<Design-Storage,`**Storage**`>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its API in an interface with the same name as the component.
* Exposes its functionality using a `**{Component Name}Manager**` class.

For example, the `**Logic**` component (see the class diagram given below) defines its API in the _Logic.java_ interface and exposes its functionality using the _LogicManager.java_ class.

.Class diagram of the `**Logic**` component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The sequence diagram below shows how the components interact with each other for the scenario where the user issues the command: **delete i/1**.

.Component interactions for **delete i/1** command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the `**UI**` component
image::UiClassDiagram.png[]

API : link:{repoURL}/src/main/java/thrift/ui/Ui.java[`_Ui.java_`]

The UI consists of a `**MainWindow**` that is made up of parts e.g.`**BalanceBar**`, `**CommandBox**`, `**ResultDisplay**`, `**TransactionListPanel**`, `**StatusBarFooter**` etc. All these, including the `**MainWindow**`, inherit from the abstract `**UiPart**` class.

The `**UI**` component uses JavaFx UI framework. The layout of these UI parts are defined in matching _.fxml_ files that are in the _src/main/resources/view_ folder. For example, the layout of the link:{repoURL}/src/main/java/thrift/ui/MainWindow.java[`**MainWindow**`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`**MainWindow.fxml**`]

The `**UI**` component does the following actions:

* Executes user commands using the `**Logic**` component.
* Listens for changes to `**Model**` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the `**Logic**` component
image::LogicClassDiagram.png[]

API : link:{repoURL}/src/main/java/thrift/logic/Logic.java[`_Logic.java_`]

`**Logic**` is an interface where `**LogicManager**` implements, allowing access to the API. The following items are examples on how the `**LogicManager**`
class can be interacted with:

.  `**LogicManager**` uses the `**ThriftParser**` class to parse the user command.
.  This results in a `**Command**` object which is executed by the `**LogicManager**`.
.  The command execution can affect the `**Model**` (e.g. adding a `**Transaction**`).
.  The result of the command execution is encapsulated as a `**CommandResult**` object which is passed back to the `**Ui**`.
.  In addition, the `**CommandResult**` object can also instruct the `**Ui**` to perform certain actions, such as displaying help to the user.

Given below is the sequence diagram for interactions within the `**Logic**` component for the **execute("delete i/1")** API call.

.Interactions inside the `**Logic**` component for the `delete i/1` command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the `**Model**` component
image::ModelClassDiagram.png[628, 600]

*API* : link:{repoURL}/src/main/java/thrift/model/Model.java[`_Model.java_`]

The `**Model**`,

* stores a `**UserPref**` object that represents the user's preferences.
* stores `**THRIFT**` data.
* stores `**BudgetList**` which contains budget set for different months by the user.
* stores `**PastUndoableCommands**` which keeps track of undoable commands for future undo and redo operation.
* exposes an unmodifiable `**ObservableList<Transaction>**` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `**THRIFT**`, which `**Transaction**` can reference. This would allow `**THRIFT**` to only require one `**Tag**` object per unique `Tag`, instead of each `**Transaction**` needing their own `**Tag**` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the `**Storage**` component
image::StorageClassDiagram.png[]

API : link:{repoURL}/src/main/java/thrift/storage/Storage.java[`_Storage.java_`]

The `**Storage**` component,

* can save `**UserPref**` objects in json format and read it back.
* can save the `**THRIFT**` data in json format and read it back:
** `**JsonAdaptedTransaction**` stores `**Transaction**` objects in `JSON` format.
** `**JsonAdaptedTag**` stores `**Tag**` objects in `JSON` format, nested under `**JsonAdaptedTransaction**`.
** `**JsonAdaptedBudget**` stores `**Budget**` objects in `JSON` format.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `**thrift.commons**` package.

== Implementation

This section describes some noteworthy details on how we implemented certain features and various considerations
that we had.

//tag::addtransaction[]
=== Adding transactions
We allow users to add `**Expense**`/`**Income**` transactions into `**THRIFT**` which enables record-keeping. This section will show how we handle such
requests from the user at the back-end.

==== Implementation
We store every single `**Transaction**` added by the user into an `**ObservableList<Transaction>**`, which is a list object in `**TransactionList**`. We used an `**ObservableList**` because whenever there are changes to the list, any other component
of `**THRIFT**` using it will automatically reflect its changes.

We implemented adding a `**Transaction**` through the following commands: **add_expense**/**add_income**. This process leverages on polymorphism: `**Expense**` and `**Income**` are both subclasses of the abstract class `**Transaction**`.
Each `**Transaction**` contains the following mandatory fields: `**Description**`, `**TransactionDate**` and `**Value**`; as well as optional fields: `**Remark**`,
and `**Set<Tag>**`. The following class diagram depicts this relation:

image::add-transaction/Polymorphism.png[]

Because of this polymorphism relation, many of the driver functions in `**THRIFT**` simply references `**Transaction**` and it will work for both `**Expense**`
and `**Income**` transaction objects. For example, when inserting a new `**Expense**`/`**Income**`, the `**AddTransactionCommandParser**` will determine
which object to initialize. The sequence diagram below shows how adding a `**Transaction**` work in the back-end:

.Sequence diagram of how adding a new `Transaction` is processed with polymorphism
image::add-transaction/PolymorphismCalling.png[]

`**Expense**` and `**Income**` are normally instantiated by either `ExpenseCommandParser#parse(String args)` or `IncomeCommandParser#parse(String args)`, which
attempts to parse the various parameters supplied in `args` and return either a `**Expense**` or `**Income**` object. The following conditions will cause a `**ParseException**`
to be thrown by the parser:

. Missing parameters
. Incorrect syntax (i.e. missing prefix, if it is required)
. Illegal values in parameters (i.e. special characters and symbols entered for a integer-only field)
. Multiple occurrences of parameters which only expects a single entry

[NOTE]
If the user input is incorrect due to any of the reasons above, the usage syntax will be shown.

We will demonstrate how a `**Transaction**` is added into `**THRIFT**` and how the back-end handles each step of the process:

Step 1. The user executes **add_expense n/Laksa v/3.50** to insert an `**Expense**` with its `**Description**` set to "Laksa"
and its `**Value**` set to "3.50". The `**TransactionDate**` is set to the user's current system date in the form "dd/mm/yyyy".
The input is now checked and an attempt to parse each parameter occurs:

* `**Description**` is parsed by `AddTransactionCommandParser#parseTransactionDescription(ArgumentMultimap)`
* `**Value**` is parsed by `AddTransactionCommandParser#parseTransactionValue(ArgumentMultimap)`
* `**TransactionDate**` is instantiated by `AddTransactionCommandParser#parseTransactionDate()`

NOTE: `**ArgumentMultimap**` is a class that stores all the parsed parameters taken from the user input.

Since the user input is valid, the `**Expense**` is successfully created and inserted into the transaction list.
The transaction list now contains 1 `**Transaction**` object.

image::add-transaction/AddTransaction1.png[]

Step 2. The user executes **add_income n/Bursary v/500 r/Awarded for doing well in school** to insert an `**Income**`.
The input is now checked in a similar fashion as in Step 2 except that:

* `**Remark**` is parsed by `AddTransactionCommandParser#parseTransactionRemark(ArgumentMultimap)`

Again, since the input is valid, the `**Income**` is successfully added into the transaction list. The transaction list
now contains 2 `**Transaction**` objects.

image::add-transaction/AddTransaction2.png[]

The following activity diagram summarizes what happens when the user executes a command to add a new `**Transaction**`:

.Activity diagram of adding a `**Transaction**` into the transaction list
image::add-transaction/AddTransactionActivity.png[, 650]

==== Design considerations
There are many different ways to implement how a transaction is added into `**THRIFT**`. In this section, we will be
justifying why we chose to implement it the way we did.

===== Aspect: Differentiating between `**Expense**` and `**Income**`
* **Alternative 1: (current choice):** Introduce a `**Transaction**` parent class which both `**Expense**` and `**Income**`
extends from.
** Pros: Introduces polymorphism, easing references to either classes by simply referencing the `**Transaction**` object.
For example, using a single `**List<Transaction>**` instead of needing 2 separate lists `**List<Expense>**` and `**List<Income>**`.
** Cons: Reduces the readability of the program as polymorphism can be confusing.

* **Alternative 2:** Keep `**Expense**` and `**Income**` classes separate, with each having their own specialized methods.
** Pros: Maintains an intuitive design: `**Expense**` deducts money and `**Income**` increases money.
** Cons: Incurs significant overhead and duplicated codes since it is likely that both `**Expense**` and `**Income**` will
have very similar methods.

Alternative 1 was chosen because we want to model it close to the real world: both `**Expense**` and `**Income**` are described
as being a `**Transaction**`.

===== Aspect: Managing how `**Value**` is stored and handled in `**Expense**` and `**Income**`
* **Alternative 1: (current choice):** Disallow negative `**Value**` in `**Expense**` object, only using positive amount
for both `**Expense**` and `**Income**`
** Pros: Removes the need to implement support for inserting negative `**Value**`. This is due to how `**Value**` constraints
are applied when restoring `**THRIFT**` data from the data file.
** Cons: Requires the developer to manually negate the `**Value**` whenever calculations are done with a `**Expense**` object.

* **Alternative 2:** Allow only negative amount in `**Expense**` object and only positive amount in `**Income**` object
** Pros: Calculating the balance becomes trivial - simply sum up the entire `**List<Transaction>**`.
** Cons: Parsing the user input to allow only a single negative symbol and no other symbols causes an overhead.

Alternative 1 was chosen because we want to keep the transaction list clean - only positive integers are stored.
//end::addtransaction[]

//tag::setbudget[]
=== Setting budgets
We allow the user to maintain a `**Budget**` for each calendar month. This section details how `**THRIFT**` handles
requests made by the user who is trying to set a budget for their desired month. Each `**Budget**` stores a `**Calendar**` attribute `period`
and a `**BudgetValue**` attribute `value`. The following class diagram shows how a `**Budget**` object looks like:

image::add-budget/BudgetClassDiagram.png[]

==== Implementation
We store every `**Budget**` set by the user into `**BudgetList**`, which is a class containing a `**List**` object named `internalList`.
This list will contain only one `**Budget**` object for each month, with the month uniqueness indicated by `period` in the "MM/YYYY" format.
Below is a class diagram explaining how the relations look:

image::add-budget/BudgetListClassDiagram.png[]

Whenever the user attempts to set a `**Budget**`, `**THRIFT**` will check if that `**Budget**` currently exists in `internalList`.
To facilitate the checking, `**BudgetList**` contains a few methods that simplify the process:

. `BudgetList#getBudgetForMonthYear(Calendar toCheck)` - Checks if `toCheck` matches any of the `period` from a `**Budget**` in `internalList`.
. `BudgetList#setBudget(Budget toSet)` - Adds `toSet` into `internalList`, possibly overwriting a `**Budget**` in `internalList` if its `period` matches the `period` in `toSet`.
. `BudgetList#removeBudget(Budget toRemove)` - Removes `toRemove` from `internalList`.

We will demonstrate what happens at the back-end whenever the user sets a budget and overwrites it afterwards. The user has not set any `**Budget**`
before, so `internalList` is empty:

Step 1. The user wishes to set their budget for October 2019 as $1500. They execute the command: **budget v/1500 d/10/2019**.
The user's entry is checked by `BudgetCommandParser#parse()` and an attempt to parse each parameter occurs:

* `**Calendar**` is parsed by `ParseUtil#parseDate(ArgumentMultimap)`
* `**BudgetValue**` is parsed by `ParseUtil#parseBudgetValue(ArgumentMultimap)`

NOTE: `**ArgumentMultimap**` is a class that stores all the parsed parameters taken from the user input.

Since the user input is valid, the `**Budget**` is successfully created and inserted into `internalList`.

Step 2. The user wishes to set a new budget for October 2019 as $2000. They execute the command: **budget v/2000 d/10/2019**.
The user's entry is once again checked to be valid and a new `**Budget**` is created. Before it is inserted into
`internalList`, a check to see if a budget is already set for that month will occur. Since there is already a
budget set for October 2019, the existing budget is replaced by this newly created `**Budget**`.

The following code snippet is part of `BudgetList#setBudget(Budget toSet)` and demonstrates how this checking is done:

.BudgetList.java
[source,java]
----
// The following variable is declared above:
// List<Budget> internalList = new ArrayList<>();

Optional<Budget> optBudget = getBudgetForMonthYear(toSet.getBudgetDate());
if (optBudget.isPresent()) {
    Budget existingBudget = optBudget.get();
    internalList.set(internalList.indexOf(existingBudget), toSet);
} else {
    internalList.add(toSet);
}
----

The sequence diagram below depicts what was just elaborated:

.Sequence diagram showing how a `**Budget**` is set
image::add-budget/BudgetSequenceDiagram.png[]

==== Design considerations
We have considered various ways as to how `**Budget**` should be stored in `**THRIFT**`. In this section, we will explain the
rationale on our course of actions.

===== Aspect: Treat `**Budget**` as an `**Income**`, therefore extending from `**Transaction**`
* **Alternative 1 (current choice):** `**Budget**` should remain separate from `**Transaction**` as it can introduce unnecessary
coupling. Budget does not need to contain `**Remark**` nor `**Tag**`.
** Pros: Freedom in dealing with `**Budget**` objects, no need to comply with `**Transaction**` attributes.
** Cons: Overhead in dealing with a separate list in `**Thrift**` class, ultimately requiring 2 lists to hold `**Transaction**`
and `**Budget**` respectively.
* Alternative 2: `**Budget**` should extend `**Transaction**` since it is somewhat a form of `**Income**`.
** Pros: Able to store `**Budget**` into `**TransactionList**`, resulting in only one list to manage. `**Budget**` can also
be easily displayed as a `**Transaction**` card on the UI, reducing the need to handle a separate list.
** Cons: May cause possible complications to arise if the user wishes to set a different budget and the `**TransactionList**`
is huge. `**THRIFT**` needs to look through the huge list to find the `**Budget**` to replace.

Again, we went with alternative 1 because we wanted to simulate the real-world relation. Otherwise, there might be confusion
since `**Budget**` is not really related to `**Transaction**` in the real world.
// end::setbudget[]

// tag::taguntag[]
=== Tag/Untag feature

We allow the user to add and remove custom `**Tag**` objects in `**Transaction**` entries so that they can categorise and partition the entries to their own liking.
The following sections describe how this feature is implemented and the design considerations that led up to the solution.

==== Implementation

The **tag**/**untag** command performs modifications on existing `**Transaction**` entries. Due to polymorphism, both `**Expense**` and `**Income**` objects extends the abstract class `**Transaction**`, and are treated the same way in the context of the **tag**/**untag** command.

.A class diagram illustrating the implementation of `**Tag**` inside a `**Transaction**`
image::tag-untag/TagPolymorphism.png[]

Due to polymorphic nature of `**Transaction**`, many of the driver functions in `**THRIFT**` uses the `**Transaction**` class for both `**Expense**`
and `**Income**` objects. For example, when tagging a new `**Expense**`/`**Income**` object, the `**TagCommandParser**` will treat them as the same object:

.An sequence diagram showing how the `**TagCommandParser**` is called
image::tag-untag/TagSequence.png[]

When a user enters a **tag**/**untag** command, it is parsed by the respective `TagCommandParser#parse(String args)` and `UntagCommandParser#parse(String args)` parsers and returns a `**TagCommand**` command object or a `**UntagCommand**` command object  respectively, which will be executed. For both commands, the following conditions will cause a `**ParseException**` to be thrown by their respective parsers:

. Missing parameters
. Incorrect syntax (i.e. missing prefix, if it is required)
. Illegal values in parameters (i.e. non-alphanumeric values given for `**Tag**` names)
. Multiple occurrences of parameters which only expects a single entry

[NOTE]
If the user input is incorrect due to any of the reasons above, the corresponding usage syntax will be shown.

The following is an example on how a `**Tag**` is added and removed from a `**Transaction**`, with details on the processes in the backend.

Step 1. The user launches the application with data from previous sessions. THRIFT contains two `**Transaction**` objects and the user is going to perform tagging and un-tagging operations on one of them.

image::tag-untag/TagUntag1.png[]

Step 2. The user executes the command **tag i/1 t/Delicious** to tag the `**Transaction**` at `**Index**` 1 with the `**Tag**` "Delicious". The input is checked with a `**TagCommandParser**` parser and an attempt to parse each parameter occurs:

* `**Index**` is parsed by `ParserUtil#parseIndex(String)`
* `**Tag**` strings are parsed by `ParserUtil#parseTags(Collection<String>)` which calls `ParserUtil#parseTag(String)` iteratively for every string in the collection

TIP: `**ParserUtil**` is a class that contains useful functions for parsing the inputs from the user.

[NOTE]
Tags that already exist inside the specified `**Transaction**` will be ignored, and if that results in no tags being added, an error will be shown to the user.

Since the user input is valid, a `**TagCommand**` command object is created and executed. As a result, a copy of the `**Transaction**` object with the specified `**Tag**` added replaces the original in the `**TransactionList**` at the same position.

image::tag-untag/TagUntag2.png[]

Step 3. The user realises that the `**Tag**` added was not appropriate. The user then executes the command **untag i/1 t/Delicious** to untag the `**Tag**` "Delicious" from the `**Transaction**` at `**Index**` 1. The input is now checked with a `**UntagCommandParser**` parser and similarly, an attempt to parse each parameter occurs.

* `**Index**` is parsed by `ParserUtil#parseIndex(String)`
* `**Tag**` strings are parsed by `ParserUtil#parseTags(Collection<String>)` which calls `ParserUtil#parseTag(String)` iteratively for every string in the collection

[NOTE]
Tags that do not exist inside the specified `**Transaction**` will be ignored, and if that results in no tags being deleted, an error will be shown to the user.

Again, since the user input is valid, a `**UntagCommand**` command object is created and executed. As a result, a copy of the `**Transaction**` object with the specified `**Tag**` deleted replaces the original in the `**TransactionList**` at the same position.

image::tag-untag/TagUntag1.png[]

The following activity diagrams summarises what happens when the user executes a command to **tag** a `**Transaction**`.

.Activity diagram of the tagging process
image::tag-untag/TagActivity.png[]

The **untag** command follows the same flow except for the following differences:

* Continues with the operation only if at least some `**Tag**` objects exist in `**Transaction**` to be un-tagged

* Ignores `**Tag**` objects that do not already exist in the `**Transaction**` as they are not valid for deletion

==== Design considerations

===== Aspect: Mutability of `**Transaction**` objects

The mutability of the `**Transaction**` objects will affect how well the code follows convention, and here are two designs that can be considered:

* **Alternative 1: (current choice)**: Create a copy of the `**Transaction**` object with modified tags and replace the original in the `**TransactionList**`
** Pros: Adheres to the Open-Closed principle of the SOLID design principles, guarantees the resultant `**Transaction**` to be as expected and not modified incorrectly during the **tag**/**untag** process.
** Cons: Creates a copy of the `**Transaction**` during the **tag**/**untag** process and increases the space complexity of the process.

* **Alternative 2**: Modify the `**Transaction**` object directly to modify tags.
** Pros: Modifies the `**Transaction**` object in place, thus the space complexity of the process is constant.
** Cons: Violates the Open-Closed principle of the SOLID design principles, the `**Transaction**` object can be modified incorrectly during the **tag**/**untag** process.

Alternative 1 was chosen as we want to ensure the correctness of the **tag**/**untag** process.

===== Aspect: Uniqueness of `**Tag**` objects within a `**Transaction**`
The uniqueness of `**Tag**` objects within a `**Transaction**`  will determine how meaningful a tag is, and here are two designs that can be considered:

* **Alternative 1:** Do not check if the `**Tag**` objects exist(s) within a `**Transaction**` when adding `**Tag**` objects and implicitly allow duplicates.
** Pros: Results in a simpler implementation of **tag** command, as there is no need to check for potential duplicates.
** Cons: Makes each tag less meaningful as they are not longer unique.

* **Alternative 2: (current choice)** Check if the `**Tag**` objects exist(s) within a `**Transaction**` when adding `**Tag**` objects, explicitly prevent duplicates.
** Pros: Makes each tag more meaningful as they are unique.
** Cons: Results in a more complex implementation of the **tag** command, as there is a need to check for potential duplicates.

Alternative 2 was chosen as we want to ensure that tags are meaningful to the user.

// end:taguntag[]

=== Updating transactions
The **update **functionality modifies details of a specified `**Transaction**` in the existing list and saves modifications to the external storage file.

==== Implementation
**Update** mechanism utilizes <<Design-Logic, *Logic*>> operations with the `**UpdateCommand**` class in place of `**Command**`, and a unique `**UpdateCommandParser**` class.
The following methods are concrete implementations for **update** operations:

* `UpdateCommandParser#parse()` - Parses the user's input and creates an `**UpdateCommand**` to execute the command.
* `UpdateCommand#execute()` - Modifies the `**Transaction**` in `**Model**` with new details and returns a `**CommandResult**` (<<Design-Logic, Step 4 of Logic>>).
* `TransactionList#setTransactionWithIndex()` - Sets the modified `**Transaction**` to its correct position in the existing `**TransactionList**`.
- This `**TransactionList**` is wrapped in `**Thrift**` and its `setTransactionWithIndex()` is called through `Thrift#setTransactionWithIndex()`.
- `Thrift#setTransactionWithIndex()` is exposed in the `**Model**` interface as `Model#setTransactionWithIndex()`.

The following Object Diagram illustrates objects involved in the execution of **update** command:

.Existing objects when executing **update** on an `**Income**`
image::update/updateDG/UpdateObjectDiagram.png[]

===== Example of usage
Given next is an example usage scenario for updating a transaction and explanation of how the **update** mechanism behaves at each step:

Step 1. The user starts up the application with an initial list loaded from external storage file. The diagram here depicts the example list used throughout this scenario.

:figure-caption!:
.Example list on startup
image::update/updateDG/UpdateStep1.png[,650]

Step 2. The user inputs **update i/1 n/Government Bursary v/600** to update the 1st transaction's name to "Government Bursary" and value to "600". Input is parsed by `UpdateCommandParser#parse()` which creates an `**UpdateCommand**`.

[NOTE]
The 1st transaction specified here is an `**Income**`.

.Example user input for update command
image::update/updateDG/UpdateStep2.png[,650]

Step 3. `UpdateCommand#execute()` creates a new transaction that reflects the changes and gets the index of current transaction to be updated.

.Creation of new updated transaction in `UpdateCommand#execute()`
image::update/updateDG/UpdateStep3.png[,650]

Step 4. `UpdateCommand#execute()` replaces original transaction in the list with the updated transaction.

image::update/updateDG/UpdateStep4Part1.png[,650]
image::update/updateDG/UpdateStep4Part2.png[,650]
.Replacement of original transaction with updated transaction by `UpdateCommand#execute()`
image::update/updateDG/UpdateStep4Part3.png[,650]

The following code snippet from `UpdateCommand#execute()` shows the creation of an updated transaction and the replacement of the original transaction with the updated one:

.UpdateCommand#execute()
[source, java]
----
// updateTransactionDescriptor is a class containing details to be contained by the new updated transaction.

transactionToUpdate = lastShownList.get(index.getZeroBased());

// ...Status message code omitted...

updatedTransaction = createUpdatedTransaction(transactionToUpdate, updateTransactionDescriptor);

// ...Logging and status message code omitted...

actualIndex = model.getIndexInFullTransactionList(transactionToUpdate).get();
model.setTransactionWithIndex(actualIndex, updatedTransaction);
----

===== Execution observed by user
The following activity diagram gives an overview of what the user observes when executing **update** command:

:figure-caption: Figure
.Activity diagram for execution of update command
image::update/updateDG/UpdateActivityDiagram.png[]

==== Design considerations
===== Aspect: Modifying details of a transaction
* **Alternative 1 (current choice)**: Replace the original transaction with a new updated transaction.
- Pros: Easy to implement and keep track of new objects containing new details.
- Cons: Incurs overhead when creating new instance of `**Transaction**`.

* **Alternative 2**: Modify the transaction directly using setter methods.
- Pros: Easy to implement and highly efficient.
- Cons: Allowing modification of transactions violates immutability principle, possibly resulting in bugs for UI or accessing modified transaction fields if there is delay in updating.

**Alternative 1 chosen** to maintain better coding practices and keep transactions immutable for the entire project. Overhead of creating new `**Transaction**` object not a significant factor as it is not a very large object.

===== Aspect: Method of replacing original transaction with updated version
* **Alternative 1 (current choice)**: Get the index of original transaction in the transactions list and `set` updated transaction to that index.
- Pros: High level of certainty that updated transaction replaces the correct outdated transaction and occupies the correct index in the list. Highly efficient.
- Cons: A little more coding required to get the index of original transaction.

* **Alternative 2**: Iterate through the transactions list and directly set the updated transaction at the first instance of original transaction found.
- Pros: Under the assumption that each `**Transaction**` is unique, index to replace can be easily found by iterating through the list with a simple loop.
- Cons: Efficiency decreases as transactions list size increases. If transactions not unique, incorrect transaction may be replaced if a transaction identical to the one supposed to be replaced is found earlier in the list.

=== Cloning transactions
The **clone** feature creates one or more duplicates of a specified `**Transaction**` and adds them to the end of the existing transactions list.

==== Implementation
An `**Index**` and `**Occurrence**` are obtained from their representation in user input. The `**Index**` specifies which transaction to clone, while the `**Occurrence**` informs THRIFT how many clones of the transaction should be created (`Occurrence#numOccurrences`) and the time period between them (`Occurrence#frequency`).

Here is a Class Diagram for the implementation of `**Occurrence**`:

.Implementation of `**Occurrence**` class
image::clone/cloneDG/OccurrenceClassDiagram.png[]

The *clone* functionality is facilitated by common <<Design-Logic, *Logic*>> operations and classes for commands, with feature-specific classes `**CloneCommand**` in place of `**Command**`, and `**CloneCommandParser**`.
The following methods are concrete implementations unique to **clone**:

* `CloneCommandParser#parse()` - Parses user input to extract an `**Index**` and create an `**Occurrence**`, then passes them as parameters to a new `**CloneCommand**` for execution.
* `CloneCommand#execute()` - Adds one or more identical copies of specified `**Transaction**` to `**Model**`, then returns a `**CommandResult**` (<<Design-Logic, Step 4 of Logic>>).

The following Sequence Diagram illustrates **clone** command execution:

.Sequence diagram for **clone** execution with 12 occurrences on an `**Expense**`
image::clone/cloneDG/CloneSequenceDiagram.png[]

===== Example of usage
Given next is an example usage scenario for cloning a transaction and explanation of how the **clone** mechanism behaves at each step:

[NOTE]
This entire scenario uses the list of all transactions.

Step 1. The user starts up the application with an initial list loaded from external storage file. The diagram here depicts the example list used throughout this scenario. In particular, this example will observe the cloning of the transaction at index 4.

:figure-caption!:
.Example list on startup
image::clone/cloneDG/CloneStep1.png[,650]

Step 2 (i). The user inputs **clone i/4** or **clone i/4 o/daily:0** to create 1 copy of the transaction at index 4 on the date when command is called - for this example, current date when command is used is 02/12/2019.

image::clone/cloneDG/CloneStep2Part1.png[,650]
.Creating one copy of transaction at index 4 and adding it to the list.
image::clone/cloneDG/CloneStep2Part2.png[,650]

Step 2 (ii). The user removes the clone created in Step 2 (i) using **delete i/6** command.

Step 3. The user inputs **clone i/4 o/monthly:12** to create 12 copies of the transaction at index 4 with dates one month apart from each other (30/12/2019 to 30/11/2020), and add them to the list. Input is parsed by `CloneCommandParser#parse()` which creates a `**CloneCommand**`.

image::clone/cloneDG/CloneStep3.png[,650]

Step 4. `CloneCommand#execute()` creates copies of the transaction to be cloned with their dates of occurrence set one month apart. The copies are then added to the list.

image::clone/cloneDG/CloneStep4Part1.png[,650]
image::clone/cloneDG/CloneStep4Part2.png[,650]
.Creating copies of transaction at index 4 and adding them to the list.
image::clone/cloneDG/CloneStep4Part3.png[,650]

===== Execution observed by user
The following activity diagram gives an overview of what the user observes when executing **clone** command:

:figure-caption: Figure
.Activity diagram for execution of **clone** command
image::clone/cloneDG/CloneActivityDiagram.png[]

==== Design considerations

===== Aspect: Representing occurrences for execution
* **Alternative 1 (current choice)**: Implement a new class `**Occurrence**` to represent occurrences.
- Pros: Good Object-Oriented Programming design adhering to principles of abstraction and encapsulation. Utility methods to process occurrences can be kept in a single class.
- Cons: More code and memory required for entire `**Occurrence**` class.

* **Alternative 2**: Directly pass the results from parsing occurrence representation in user input as parameters to execution methods.
- Pros: Quick and efficient in producing parameters for execution.
- Cons: May be complicated to trace parameters when passing between different methods. Unable to implement utility methods to process occurrences within a single class.

===== Aspect: Maintaining a store for valid values of `Occurrence#frequency`
* **Alternative 1 (current choice)**: Store valid `frequency` values within a static non-modifiable "final" array inside `**Occurrence**`
- Pros: Implementation is simple with relatively little coding needed. Values cannot be modified after initialization of array, preventing invalid values from being added later.
- Cons: An additional field of type array has to be included in `**Occurrence**` class.

* **Alternative 2**: Store valid values as `**Enum**`
- Pros: Validity of values in `**Enum**` form all but assured, there will never be invalid values.
- Cons: More code and memory required for entire `**Enum**` classes.


=== Undo/Redoing undoable commands
*Undo* command allows the user to revert `**THRIFT**` to its previous state when they have made a mistake. *Redo* command does
the opposite of *undo* command, useful for when the user wishes to execute the command instead.

The underlying data structure of the undo and redo feature is implemented in `**PastUndoableCommands**`. It consists of two stacks:
`UndoStack` and `RedoStack`. It provides the following methods:

* `PastUndoableCommands#addPastCommand(Undoable undoable)` -- Keeps track of the undoable commands.
* `PastUndoableCommands#getCommandToUndo()` -- Retrieves undoable commands from `UndoStack` for user to perform undo.
* `PastUndoableCommands#hasUndoable()` -- Checks if there are any commands to perform undo.
* `PastUndoableCommands#getCommandToRedo()` -- Retrieves undone commands from `RedoStack` for user to perform redo.
* `PastUndoableCommands#hasRedoCommand()` -- Checks if there are any commands to perform redo.

The function wrappers to these methods are `Model#keepTrackCommands(Undoable command)`, `Model#getPreviousUndoableCommand()`, `Model#hasUndoableCommand()`,
`Model#getUndoneCommand()` and `Model#hasUndoneCommand()` respectively.

NOTE: Undoable commands are *add_expense*, *add_income*, *clone*, *delete*, *tag*, *untag*, *update*.

Every undoable command will be stored in the `UndoStack` once it is executed. It will only be stored in `RedoStack` when the user executed
*undo*.

==== Implementation
The below scenario illustrates how undo and redo feature works:

Step 1. The application is launched with an empty transaction list. Both `UndoStack` and `RedoStack` are empty upon initializing `**PastUndoableCommands**`.

image::UndoAndRedo/initialUndoRedo.PNG[338, 300]

Step 2. The user executes *add_expense n/Laksa v/4* to add Laksa to the `**TransactionList**`.
The `**LogicManager**` invokes the method `Model#keepTrackCommands(Undoable undoable)` to keep track of the `**AddExpenseCommand**` object
that was used to add Laksa. This `**AddExpenseCommand**` object is pushed into `UndoStack`.

image::UndoAndRedo/addExpense.PNG[357, 300]

Step 3. The user executes *update i/1 v/3.50* to update the cost of the Laksa to $3.50.
The `**LogicManager**` calls the method `Model#keepTrackCommands(Undoable undoable)` to keep track of the `**UpdateCommand**` object
that was used to update the cost of the Laksa. This `**UpdateCommand**` object is pushed into `UndoStack`.

image::UndoAndRedo/updateExpense.PNG[341, 300]

Step 4. The user executes *undo* to revert the cost of the Laksa to $4.00.
The `**UndoCommand**` invokes the method `Model#getPreviousUndoableCommand()` to retrieve the `**UpdateCommand**` object.
`**UpdateCommand**` is popped from `UndoStack` and pushed into `RedoStack` before being returned to the callee.

image::UndoAndRedo/undo.PNG[320, 300]

Step 5. The user executes *undo* to remove Laksa from `**TransactionList**`.
The `**UndoCommand**` invokes the method `Model#getPreviousUndoableCommand()` to retrieve the `**AddExpenseCommand**` object.
`**AddExpenseCommand**` is popped from `UndoStack` and pushed into `RedoStack` before being returned to the callee.

image::UndoAndRedo/undo2.PNG[326, 300]

The sequence diagram shows how *undo* work for *add_expense* command:

.Sequence diagram of how *undo* command is applied at the back-end
image::UndoAndRedo/UndoAddExpenseSequenceDiagram.png[]

Step 6. The user executes *redo* to add Laksa back to `**TransactionList**`.
The `**RedoCommand**` invokes the method `Model#getUndoneCommand()` to retrieve the `**AddExpenseCommand**` object.
`**AddExpenseCommand**` is popped from `RedoStack` and pushed into `UndoStack` before being returned to the callee.

image::UndoAndRedo/redo.PNG[325, 300]

NOTE: All commands stored in `RedoStack` are purged when the user executes another undoable command.

The sequence diagram shows how *redo* work for *add_expense* command:

.Sequence diagram of how *redo* command is applied at the back-end
image::UndoAndRedo/RedoAddExpenseSequenceDiagram.png[]

The following activity diagram shows what happens if the user executes a command:

.Activity diagram of the command execution.
image::UndoAndRedo/RunCommandActivityDiagrams.png[]

==== Design considerations

===== Aspect: Data structure used to keep track of undoable command

* **Alternative 1 (current choice):** Use two stacks. One stack stores the command to undo while the other stack stores the command to redo.
** Pros: Easy to implement.
** Cons: Need to carefully manage the two stacks. For example, you need to pop the command from one stack and push it into another stack.
* **Alternative 2:** Use an arraylist and a pointer to indicate the next command to undo.
** Pros: Easy to implement.
** Cons: Need to carefully manage the pointer. For example, you need to ensure that the pointer stays within the size of an arraylist.

// tag::Filtering transactions[]
=== Filtering transactions

The *List* command allows the user to bring up a list of `**Transactions**`, and filter it by month.
This feature is implemented by using a `**Predicate<Transaction>**` to filter the `**Transactions**` by month.

==== Implementation
`**ListCommand**` is instantiated by `ListCommandParser#parse(String args)`,
which attempts to parse the various parameters supplied in `args` and return a `**ListCommand**` object.

The sequence diagram below shows how the execution of the **list** is like:

.Sequence diagram of how *list* command is applied at the back-end.
image::list/ListSequenceDiagram.png[]

The following conditions will cause a `**ParseException**` to be thrown by the parser:

. Incorrect syntax (i.e. having a prefix that does not refer to month)
. Illegal values in parameters (i.e. special characters and symbols entered for a integer-only field)

[NOTE]
If the user input is incorrect due to the reasons above, the usage or parameter syntax will be shown.

The scenario below shows an example of how the feature works:

Step 1. The user executes *list m/10/2019* to filter the list to bring up transactions of October 2019.

image::list/Step2.png[,650]

Step 2. The `**ListCommandParser**` will parse the arguments using the method `ListCommandParser#parse(String args)`.

Step 3. Since user input is correct and the arguments have been parsed, a new `**ListCommand**` object will be created by the
`**ListCommandParser**`.

Step 4. This `**ListCommand**` object will use a `**Predicate**` based on the specified month which is used to filter through each `**Transaction**`.

Step 5. The final list of filtered transactions will be brought up. The income, expense, and balance values in the UI will
be updated accordingly as well, to reflect the correct values for the filtered month.

image::list/OctFilter.png[,650]

The activity diagram below will give an overview of what is happening when the command is executed.

.Activity diagram of the command execution.
image::list/ListActivityDiagram.png[]

==== Design considerations

===== Aspect: Using `**Predicate**` to improve extendability of the feature in the future

* **Alternative 1 (current choice):** Create a new `**Predicate**` based on the arguments each time.
** Pros: The filter feature could be added to and improved in the future to further accommodate new arguments other than month and tag,
and still be able to filter by a combination of the different arguments.
** Cons: Not as easy to implement.
* **Alternative 2:** Use a fixed `**Predicate**` written beforehand to filter the list for each argument.
** Pros: Straightforward to implement, a specific `**Predicate**` can be used for the specific argument.
** Cons: Not easily extendable as in the future if we want to filter by new arguments, we will have to write a new `**Predicate**` for each argument.

Eventually we may decide to use a combination of both alternatives as it is possible that different arguments are easier to
implement using different methods.

==== Proposed extension
In the near future, we plan to enhance the filtering feature. We want to improve the list command to take in tags as a
possible argument similar to month, and thus allow for the possible filtering by tags as well. The design considerations mentioned
earlier was to facilitate this proposed extension, since we would require the use of a `**Predicate**` which will be
created using the tag in the argument as well. By doing so, we reduce the difficulty of enhancing the filtering feature in
the future. This would benefit the simplicity of the command and further enhance the user experience, for them to be able
to filter by a combination of both months and tags.

The image below shows how a possible future implementation of this feature could look like:

.Expected result of filtering by both Nov 2019 and Transport.
image::list/TagFilter.png[,550]

// end::Filtering transactions[]

//tag::dataencryption[]
=== [Proposed] Data encryption
With the emphasis on information security these days, we are concerned about protecting the privacy of our users. We have
discussed on how we can protect our users' data on `**THRIFT**` by making use of modern encryption schemes to protect against
prying eyes. The encryption will take place at the back-end with minimal disruptions to the user. The user does not need additional
knowledge about how the encryption work as `**THRIFT**` will handle all encryption and decryption operations for them.

==== Proposed implementation
In order to ensure a seamless experience, we propose a new `**Keystore**` module, along with a `**KeystoreManager**` that will
be interacting closely with the `**Logic**` and `**Storage**` modules. The class diagram below gives an overview of how the
new `**Keystore**` would fit in:

image::encryption/EncryptionClassDiagram.png[,250]

We recommend that the `**KeystoreManager**` implements the following methods:

* `KeystoreManager#setEncryptionScheme(Cipher)` - Sets the encryption scheme to be that of `Cipher`.
* `KeystoreManager#encryptThrift(Thrift)` - Encrypts the current `**Thrift**` object with the encryption scheme set in `**KeystoreManager**`.
* `KeystoreManager#decryptThrift()` - Decrypts the encrypted text file, restore the `**Thrift**` object and replace the current `**Thrift**`.

TIP: The decryption will take place upon `MainApp#init()` while encryption will happen every time `LogicManager#execute()` is called.

==== Design considerations
There is one factor about the way encryption should be implemented that we considered.

===== Aspect: Allowing the user to specify the encryption strength
* Alternative 1: The user can specify the algorithm, as well as the key size of the encryption scheme.
** Pros: Power users have the freedom to fine-tune the encryption strength to suit their needs.
** Cons: Regular users might not know which encryption scheme to use.

* Alternative 2: Preset the encryption scheme to use AES-256, which provides one of the best protections in the market
due to its key size.
** Pros: Encrypted data will be secured even if stolen, preventing unauthorised access.
** Cons: Users with slower processor chips on their computer might experience a noticeable performance drop when using
`**THRIFT**`.

We believe that both alternatives have reasonable pros and cons and choosing either option would be beneficial to `**THRIFT**`.
The added data security will assure the user that their data is safe and allows them to use `**THRIFT**` with a peace of mind.

// end::dataencryption[]

//tag::ai[]
=== [Proposed] Artificial Intelligence (AI)
Artificial intelligence (AI) is the simulation of human intelligence processes by machines such as computer systems. AI tries to mimic the learning process of humans in order to perform self-correction.
We want `**THRIFT**` to possess the ability to make calculated decisions and provide the user with appropriate recommendations under the appropriate situations.
This way, we can enhance the user experience and make our application more effective.

The following sections will describe how we plan to implement this feature and the possible design considerations.

==== Proposed Implementation
Adhering to the Open-Closed principle, we will not modify the existing architecture but extend it.
The following class diagram illustrates how we propose to do it, by adding 2 new classes to the existing architecture:

image::ai/AiClassDiagram.png[]

The new classes will have the following roles:

* `**AI**`: Analyses data from the `**Data**` and perform machine learning on it.
If the need arises, feedback to the `**Data**` class to morph the data inside.
Modifies the actions taken by the `**LogicManager**` class based on the machine learning model.

* `**Data**`:  Collects data from `**Thrift**` and formats to it to a form understandable by the `**AI**` class.
It can be modified by the `**AI**` class in the process of machine learning.

==== Design consideration

===== Aspect: Portability of the learning model

The portability of the learning model will determine the complexity of the implementation and the following designs can be considered:

* *Alternative 1*: Include the machine learning algorithms and models with the application
** Pros: Allows the application to be portable and self-contained
** Cons: Results in a larger application size

* *Alternative 2*: Develop the machine learning algorithms and models as a separate application,
which can be offloaded to a remote location
** Pros: Allows the main application to be smaller in size
** Cons: The application is no longer portable and self-contained,
and have to depend on the availability of the remote application

We believe that both alternatives can be considered as choosing either option brings a different benefit to `**THRIFT**`.
A hybrid implementation of both alternatives can also be considered.
Regardless of what is eventually chosen, the user experience will be improved by artificial intelligence.


//end::ai[]

=== Logging

We are using `**java.util.logging**` package for logging. The `**LogsCenter**` class is used to manage the logging levels and logging destinations:

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `**Logger**` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* The log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Detected a critical problem which may possibly cause the termination of the application
* `WARNING` : Exercise caution if continuing
* `INFO` : Display information showing the noteworthy actions by the application
* `FINE` : Display details that are usually not noteworthy but may be useful in debugging e.g. print the actual list
instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: _config.json_).

== Documentation
We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render .adoc files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your .adoc files in real-time.

=== Editing Diagrams

See <<UsingPlantUml#, UsingPlantUml.adoc>> to find out how to create and update the UML diagrams in the developer guide.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the _docs/_ directory to HTML format.
.  Go to your generated HTML files in the _build/docs_ folder, right click on them and select *Open with* -> *Google Chrome*.
.  Within Chrome, click on the *Print* option in Chrome's menu.
.  Set the destination to *Save as PDF*, then click *Save* to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Docs-SiteWideDocSettings]]
=== Site-wide Documentation Settings

The link:{repoURL}/build.gradle[`_build.gradle_`] file specifies some project-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how all documentation files within this project are rendered.

[TIP]
Attributes left unset in the `_build.gradle_` file will use their default value, if any.

[cols="1,2a,1", options="header"]
.List of site-wide attributes
|===
|Attribute name |Description |Default value

|`site-name`
|The name of the website.
If set, the name will be displayed near the top of the page.
|_not set_

|`site-githuburl`
|URL to the site's repository on https://github.com[GitHub].
Setting this will add a "View on GitHub" link in the navigation bar.
|_not set_
|===

[[Docs-PerFileDocSettings]]
=== Per-file Documentation Settings

Each .adoc file may also specify some file-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how the file is rendered.

Asciidoctor's https://asciidoctor.org/docs/user-manual/#builtin-attributes[built-in attributes] may be specified and used as well.

[TIP]
Attributes left unset in .adoc files will use their default value, if any.

[cols="1,2a,1", options="header"]
.List of per-file attributes, excluding Asciidoctor's built-in attributes
|===
|Attribute name |Description |Default value

|`site-section`
|Site section that the document belongs to.
This will cause the associated item in the navigation bar to be highlighted.
One of: `_UserGuide_`, `_DeveloperGuide_`, `_AboutUs_`, `_ContactUs_`

|_not set_

|`no-site-header`
|Set this attribute to remove the site navigation bar.
|_not set_

|===

=== Site Template

The files in link:{repoURL}/docs/stylesheets[_docs/stylesheets_] are the https://developer.mozilla.org/en-US/docs/Web/CSS[CSS stylesheets] of the site.
You can modify them to change some properties of the site's design.

The files in link:{repoURL}/docs/templates[_docs/templates_] controls the rendering of .adoc files into HTML5.
These template files are written in a mixture of https://www.ruby-lang.org[Ruby] and http://slim-lang.com[Slim].

[WARNING]
====
Modifying the template files in link:{repoURL}/docs/templates[_docs/templates_] requires some knowledge and experience with Ruby and Asciidoctor's API.
You should only modify them if you need greater control over the site's layout than what stylesheets can provide.
The THRIFT team does not provide support for modified template files.
====

[[Testing]]
== Testing

This section describes the type of tests used in THRIFT and how it can be executed.

=== Running Tests

There are two ways to run tests.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the _src/test/java_ folder and choose *Run 'All Tests'*
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose *Run 'ABC'*

*Method 2: Using Gradle*

* Open a console and run the command *gradlew clean test* (Mac/Linux: *./gradlew clean test*)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

=== Types of tests

We have three types of tests:

.  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `*thrift.commons.util.StringUtilTest*`
.  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `*thrift.storage.StorageManagerTest*`
.  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `*thrift.logic.LogicManagerTest*`


=== Troubleshooting Testing
**Problem: Keyboard and mouse movements are not simulated on macOS Mojave, resulting in GUI Tests failure.**

* Reason: From macOS Mojave onwards, applications without `Accessibility` permission cannot simulate certain keyboard and mouse movements.
* Solution: Open *System Preferences*, click *Security and Privacy* -> *Privacy* -> *Accessibility*, and check the box beside *Intellij IDEA*.

.`Accessibility` permission is granted to *IntelliJ IDEA*
image::testfx-idea-accessibility-permissions.png[width="600"]

== Dev ops
This section describes the practices and tools used during development.

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews

When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/thrift/MainApp.java[`_MainApp.java_`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. v0.1
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, THRIFT depends on the https://github.com/FasterXML/jackson[Jackson library] for JSON parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives:

[loweralpha]
. Include those libraries in the repo (this bloats the repo size)
. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Product scope

*Target user profile*:

* money-conscious NUS students
* number of transactions are significant and needs to be managed
* apps are preferred on desktop over other platforms
* typists that type quickly and prefers typing over mouse input
* CLI usage does not pose any discomfort

*Value proposition*:

* provides a more effective financial management compared to typical mouse/GUI driven app
* plans for future spending are made easier
* congregates all info regarding fees and costs in a single location

[appendix]
== User stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="100%",cols="5%,<25%,<30%,<40%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *`
|NUS student
|track my spending
|manage my finances better

|`* * *`
|movie addict who watches every movie that comes out
|keep track of my movie ticket and snack expenses
|have enough money to watch the movies I want.

|`* * *`
|computing student who has many software subscriptions
|use the recurring expenses tracker
|manage my subscription payments

|`* * *`
|student staying in the Halls with many expenses
|see all my expenses in a central spot
|keep track of all the different expenses

|`* * *`
|NUS international student
|keep track of my travelling and spending expenses
|have enough money when I travel around Singapore

|`* * *`
|someone who loves travelling
|use the tracker to help me plan for my travelling budgets
|fully enjoy my time on vacation

|`* * *`
|SOC student always on my laptop
|write down my expenses
|really quickly due to the command-line nature

|`* * *`
|student who uses both PayLah and cash interchangeably
|tag my expenses
|keep track of both expenses

|`* * *`
|NUS student who loans money to a lot of friends
|use the debt tracker to track and collect my interest
|

|`* * *`
|student accepting financial aid
|use the expense tracker report
|keep within my budget

|`* * *`
|student who borrows money frequently from other people
|use the debt tracker to remember who I owe money to
|

|`* * *`
|NUS international student
|be able to keep track of recurring utility expenses such as phone bills
|plan a suitable budget

|`* * *`
|phone junkie
|set aside enough money for purchasing the latest phones and accessories
|

|`* * *`
|student who is conscious about money
|be able to view my monthly expenditure
|know how much I had spent this month

|`* * *`
|female buying clothes frequently
|track exactly how much I spend on clothes each month using the tracker and filter
|don’t exceed my clothes budget

|`* * *`
|student who likes to buy games online
|use the expense tracker funds left
|see if I am able to pay my school fees

|`* * *`
|mobile game addict who makes a lot of in-app purchases
|use the expenses tracker report
|manage my finances and to sustain my essential expenses

|`* * *`
|student that frequently takes on part-time jobs
|use finance planner to track my income
|

|`* * *`
|frugal NUS student
|use the expense tracker report
|optimise my finances

|`* * *`
|social animal frequently going to clubs and bars
|plan out my expenses
|moderate my spending on social activities and keep up my balanced lifestyle

|`* * *`
|student that stays in Hall
|add my expenses to the expense tracker
|track funds contributed to hall activities

|`* * *`
|student who wants to save more money
|be able to compare my past expenditure with my current expenditure
|know if I had spent more money or saved money this month

|`* * *`
|hall resident who eats supper daily
|keep track of what I have been eating and how much I usually spend on supper
|don't overspend on each supper

|`* * *`
|child of wealthy parent
|easily delete previous expenses
|properly count my expenditure should my parents decide to help cover some parts of it

|`* * *`
|careless student
|make some changes to the information
|ensure that the application displays the correct information

|`* * *`
|student who loves to keep track of finance
|view all the possible commands
|fully utilize the functionalities offered by the application

|`* *`
|student that wants to allocate less money to material goods and more to food
|analyse the spending by category and adjust accordingly
|

|`* *`
|on-campus resident who likes to cook my own food
|track my grocery bills
|moderate the cost and frequency of grocery shopping

|`* *`
|motor enthusiast
|use the planner to set aside funds
|keep purchasing vehicle parts, modifications and accessories and keep pursuing my hobby

|`* *`
|student who has a bad habit of spending a lot on material goods
|see which goods are taking up most of my monthly budget
|better manage my finances

|`* *`
|Hypebeast that spends a lot of money on branded goods
|look at my recent spending percentage
|manage my finances and keep my budget

|`* *`
|student who is going for exchange
|make sure that I bring enough foreign currency
|avoid using my credit card

|`* *`
|student who is currently in a relationship
|the tracker to help me set aside enough money for both my partner and I
|get married soon

|`*`
|student who always lends money to people
|be able to send receipt to my loanee
|claim back my money

|`*`
|dota addict who always buy arcanas and battle pass levels
|track my spending
|afford to buy more battle pass levels

|`*`
|active youth in need of sustenance within a limited budget
|get recommendations for food prices
|be healthy physically and financially

|`*`
|shopaholic
|use the finance planner to find discounts
|spend less on my shopping

|`*`
|NUS student with stingy and over-controlling parents
|send my expense report for the month to my parents to view easily
|avoid them asking me what I have been spending on all the time

|`*`
|NUS student whose transaction details may be inaccurate in retrospect due to cashbacks or receipt discrepancies
|modify transactions in my list
|transactions have the most updated and accurate information

|`*`
|NUS student with completely or almost identical repeated transactions
|make copies of such transactions
|more convenient to add them instead of having to type them out fully each time
|=======================================================================


[appendix]
== Use cases

(For all use cases below, the *System* is the `THRIFT` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Setting monthly budget

*MSS*

1. User requests to set their monthly budget to a certain amount.
2. THRIFT processes the request and sets the amount as the monthly budget.
+
_Use case ends_

*Extensions*

[none]
* 1a. The parameters specified by the user are not valid.
+
[none]
** 1a1. THRIFT displays an invalid parameter error to the user and the monthly budget is not updated.
+
_Use case ends_

[discrete]
=== Use case: Add an expense/income transaction

*MSS*

1. User requests to add a new expense or income into the records.
2. THRIFT processes the request and adds the expense/income into the transactions list.
+
_Use case ends_

*Extensions*

[none]
* 1a. The parameters specified by the user are not valid.
+
[none]
** 1a1. THRIFT displays an invalid parameter error to the user and the transactions list is not updated.
+
_Use case ends_

[discrete]
=== Use case: Delete a transaction

*MSS*

1. User requests to delete an existing transaction from the records.
2. THRIFT processes the request and removes the transaction from the transactions list.
+
_Use case ends_

*Extensions*

[none]
* 1a. The command or transaction specified by the user is not valid.
+
[none]
** 1a1. THRIFT displays an invalid parameter error to the user and the transactions list is not updated.
+
_Use case ends_

[discrete]
=== Use case: Update a transaction's details

*MSS*

1. User requests to update a transaction's name, value, remark or tags.
2. THRIFT processes the request, updates the specified details in the transactions list and informs user of what has been changed.
+
_Use case ends_

*Extensions*

[none]
* 1a. Some parameters specified by the user are not valid.
+
[none]
** 1a1. THRIFT displays an invalid command format error to the user and does not update details for invalid parameters.
+
_Use case ends_

[discrete]
=== Use case: Clone a transaction

*MSS*

1. User requests to clone a transaction, specifying the occurrence of clones: how many clones are to be created and their frequency over a future period.
2. THRIFT processes the request and adds the specified number of identical transactions to the transactions list.
+
_Use case ends_

*Extensions*

[none]
* 1a. User does not specify the occurrence of clones.
+
[none]
** _Use case resumes from Step 2_

* 1b. The index parameter specified by the user is not valid.
+
[none]
** 1b1. THRIFT displays an invalid command format error to the user and does not update the transactions list.
+
_Use case ends_

* 1b. The occurrence specified by the user is not valid.
+
[none]
** 1b1. THRIFT displays an invalid command format error to the user and does not update the transactions list.
+
_Use case ends_

[discrete]
=== Use case: Show help window

*MSS*

1. User requests to view to syntax of a specific command.
2. THRIFT displays the syntax of the requested command.
+
_Use case ends_

*Extensions*

[none]
* 1a. The command specified by the user is not valid.
+
[none]
** 1a1. THRIFT displays an invalid command error to user.
+
_Use case ends_

[discrete]
=== Use case: List monthly transactions

*MSS*

1. User requests to view list of transactions for a specific month.
2. THRIFT displays transactions of that month.
+
_Use case ends_

[discrete]
=== Use case: Tag a transaction

*MSS*
= *Extensions*

1. User requests to tag a specific transaction.
2. THRIFT processes the request and adds the tag to the specific transaction.
+
_Use case ends_

*Extensions*

[none]
* 1a. The command specified by the user is not valid.
+
[none]
** 1a1. THRIFT displays an invalid command error to user.
+
_Use case ends_


[discrete]
=== Use case: Untag a transaction

*MSS*

1. User requests to untag a specific transaction.
2. THRIFT processes the request and removes the tag from the specific transaction.
+
_Use case ends_

*Extensions*

[none]
* 1a. The parameters specified by the user are not valid.
+
[none]
** 1a1. THRIFT displays an invalid parameter error to the user and the transaction is not updated.
+
_Use case ends_

[discrete]
=== Use case: Convert a transaction

*MSS*

1. User requests to convert the currency of a specific transaction to a new currency.
2. THRIFT processes the request and updates specific transaction with the new value in the new currency.
+
_Use case ends_

*Extensions*

[none]
* 1a. The parameters specified by the user are not valid.
+
[none]
** 1a1. THRIFT displays an invalid parameter error to the user and the transaction is not updated.
+
_Use case ends_

[discrete]
=== Use case: Convert a value

*MSS*

1. User requests to convert a value in SGD to a specific currency.
2. THRIFT processes the request and displays the new value in the new currency.
+
_Use case ends_

*Extensions*

[none]
* 1a. The parameters specified by the user are not valid.
+
[none]
** 1a1. THRIFT displays an invalid parameter error to the user.
+
_Use case ends_

[discrete]
=== Use case: Find a keyword in `**Transaction's  Remark**` and `**Description**` field

*MSS*

1. User requests to search for a keyword in THRIFT.
2. THRIFT processes its currently saved entire transaction list to look for matches.
3. THRIFT found matches and display the results at the `**TransactionListPanel**` screen.
_Use case ends_

[appendix]
== Non functional requirements

. THRIFT should be able to run on any <<mainstream-os, mainstream OS>> as long as it has `Java 11` installed.
. THRIFT should be able to hold up to 250 transactions without a noticeable drop in performance for typical usage.
. A user with above average typing speed for <<regular-english-text, regular English text>> (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
. THRIFT should be able to run with or without internet connection.
. THRIFT should work for a single user only.
. THRIFT should not require user to install.
. Features implemented should be testable using manual testing and automated testing.

[appendix]
== Glossary
[horizontal]
[[thrift]] THRIFT::
Stands for "Terminal-input Human Readable Interactive Finance Tracker". It is the application this developer guide is for.

[[api]] API::
Stands for "Application Programming Interface" which simplifies programming by abstracting the underlying implementation and only exposing objects or actions the developer needs.

[[puml]] PlantUML::
Stands for a software tool that we use to render the diagrams used in this document.

[[nfr]] NFR::
Stands for "Non-functional Requirement"

[[mainstream-os]] Mainstream OS::
Stands for commonly used Operating Systems (OS) such as Windows, Linux, Unix, OS-X

[[regular-english-text]] Regular English Text::
Stands for text with ordinary english grammar structures and vocabulary generally used by the public.
It excludes syntax related to programming and <<system-administration, system administration>>.

[[system-administration]] System Administration::
Stands for the field of work in which someone manages one or more systems, be they software, hardware, servers or workstations
with the goal of ensuring the systems are running efficiently and effectively.



[appendix]
== Instructions for manual testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launching and shutting down

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

=== Setting a monthly budget

. Setting a monthly budget to be a certain amount.

.. Test case: `budget v/1000 d/10/2019` +
    Expected: The monthly budget for `10/2019` is now set to $`1000`. Details of the new monthly budget is shown in the status message. The monthly balance in the GUI is re-calculated to reflect the updated budget.
.. Test case: `budget` +
    Expected: The monthly budget is not updated. Error details shown in the status message (missing `d/MONTH` and `v/VALUE` parameters). Status bar remains the same.
.. Test case: `budget v/10000000 d/10/2019` +
    Expected: The monthly budget is not updated. Error details shown in the status message (`v/VALUE` input exceeds constraint of 1 million). Status bar remains the same.

=== Adding a transaction

. Adding a transaction, be it income or expense.

.. Test case: `add_expense n/Bought a pair of Apple Earpods v/350` +
    Expected: A new expense transaction is added into the list. Details of the expense transaction shown in the status message. The date string is automatically saved into the transaction list.
.. Test case: `add_income n/Awarded bursary prize v/500` +
    Expected: A new income transaction is added into the list. Details of the income transaction shown in the status message. The date string is automatically saved into the transactions list.
.. Test case: `add_expense n/Lunch in school` +
    Expected: No transaction is added. Error details shown in the status message (missing `v/VALUE` parameter). Status bar remains the same.

=== Deleting a transaction

. Deleting a transaction while all transactions are listed

.. Prerequisites: List all transactions using the `list` command. Multiple transactions in the list.
.. Test case: `delete i/1` +
   Expected: First transaction is deleted from the list. Details of the deleted transaction shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete i/0` +
   Expected: No transaction is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

=== Updating a transaction's details

. Updating a transaction's details and reflecting changes in the list.

.. Prerequisites: List all transactions using the `list` command. The first transaction is `1. [-] Laksa ($10.50) [Lunch][Food]`.
.. Test case: `update i/1 n/Fried Rice` +
   Expected: Details of the updated transaction and original transaction shown in status message. Displayed list scrolls to updated item which reflects the changes.
.. Test case: `update i/1 v/20` +
   Expected: Details of the updated transaction and original transaction shown in status message. Displayed list scrolls to updated item which reflects the changes.
.. Test case: `update i/1 n/Fried Rice v/20 t/Lunch t/Food` +
   Expected: Details of the updated transaction and original transaction shown in status message. Displayed list scrolls to updated item which reflects the changes.
.. Test case: `update i/INVALID_INDEX` where `INVALID_INDEX` is a number less than 1 or more than list size. +
   Expected: No changes. Error details shown in status message.
.. Test case: `update i/1 z/Calamari` +
   Expected: No changes. Error details shown in status message.
.. Test case: `update firstTransaction` +
   Expected: No changes. Error details shown in status message.
.. Test case: `update` +
   Expected: No changes. Error details shown in status message.

=== Cloning a transaction

. Creating a duplicate of a transaction.

.. Prerequisites: List all transactions using the `list` command. At least one transaction in the list.
.. Test case: `clone i/1` +
   Expected: New transaction identical to first transaction in the list added to the bottom of the list. Details of the cloned transaction shown in the status message. Date string for new transaction is automatically saved into the transaction list.
.. Test case: `clone i/INVALID_INDEX` where `INVALID_INDEX` is a number less than 1 or more than list size. +
   Expected: No transaction is cloned. Error details shown in status message.
.. Test case: `clone firstTransaction` +
   Expected: No changes. Error details shown in status message.
.. Test case: `clone` +
   Expected: No changes. Error details shown in status message.
.. Test case: `clone i/1 o/daily:3` +
   Expected: 3 new transactions identical to first transaction in the list added to the bottom of the list, with their dates set 1 day apart.
.. Test case: `clone i/1 o/daily:-1` +
   Expected: No changes. Error details shown in status message.
.. Test case: `clone i/1 o/onceeveryday:-1` +
   Expected: No changes. Error details shown in status message.
.. Test case: `clone i/1 o/yearly:6` +
   Expected: No changes. Error details shown in status message.
.. Test case: `clone i/1 o/monthly:13` +
   Expected: No changes. Error details shown in status message.
.. Test case: `clone i/1 o/daily` +
   Expected: No changes. Error details shown in status message.
.. Test case: `clone i/1 o/monthly:5:6:fgzsfdsf:y564s:3234:` +
   Expected: No changes. Error details shown in status message.

=== Listing the transactions

. Listing out transactions by month or by tag.

.. Prerequisites: At least one transaction in the list.
.. Test case: `list` +
   Expected: The entire list of transactions will be shown.
.. Test case: `list m/01/2019` +
   Expected: The list of transactions for January 2019 will be shown.

=== Tagging a transaction

. Tagging a transaction and reflecting changes in the list.

.. Prerequisites: List all transactions using the `list` command. The first transaction is `1. [-] Laksa ($10.50) [Lunch][Food]`.
.. Test case: `tag i/1 t/EXPENSIVE` +
   Expected: Details of the tagged transaction shown in status message. Listing the transaction reflects changes.
.. Test case: `tag i/INVALID_INDEX` t/VALID_TAG` where `INVALID_INDEX` is a number less than 1 or more than list size and VALID_TAG is a valid tag. +
   Expected: No changes. Error details shown in status message.
.. Test case: `tag firstTransaction` +
   Expected: No changes. Error details shown in status message.
.. Test case: `tag` +
   Expected: No changes. Error details shown in status message.

=== Untagging a transaction

. Untagging a transaction and reflecting changes in the list.

.. Prerequisites: List all transactions using the `list` command. The first transaction is `1. [-] Laksa ($10.50) [Lunch][Food]`.
.. Test case: `untag i/1 t/FOOD` +
   Expected: Details of the untagged transaction shown in status message. Listing the transaction reflects changes.
.. Test case: `untag i/INVALID_INDEX t/VALID_TAG` where `INVALID_INDEX` is a number less than 1 or more than list size and VALID_TAG is a valid tag. +
   Expected: No changes. Error details shown in status message.
.. Test case: `untag i/VALID_INDEX t/NOT_INSIDE_TAG` where `VALID_INDEX` is a valid transaction index and NOT_INSIDE_TAG is not inside the transaction specified. +
   Expected: No changes. Error details shown in status message.
.. Test case: `untag firstTransaction` +
   Expected: No changes. Error details shown in status message.
.. Test case: `untag` +
   Expected: No changes. Error details shown in status message.

=== Converting a transaction

. Converting a transaction's currency and reflecting changes in the list.

.. Prerequisites: List all transactions using the `list` command. The first transaction is `1. [-] Laksa ($10.50) [Lunch][Food]`.
.. Test case: `convert to/USD i/1` +
   Expected: Details of the converted transaction shown in status message. Listing the transaction reflects changes.
.. Test case: `convert to/USD i/INVALID_INDEX` where `INVALID_INDEX` is a number less than 1 or more than list size. +
   Expected: No changes. Error details shown in status message.
.. Test case: `convert to/INVALID_CURRENCY i/VALID_INDEX` where `INVALID_CURRENCY` is not a supported currency and `VALID_INDEX` is a valid transaction index. +
   Expected: No changes. Error details shown in status message.
.. Test case: `convert firstTransaction` +
   Expected: No changes. Error details shown in status message.
.. Test case: `convert` +
   Expected: No changes. Error details shown in status message.

=== Converting a value

. Converting a values's currency and displaying it

.. Test case: `convert from/SGD to/USD v/VALUE`. +
   Expected: Original value and converted value displayed to the user.
.. Test case: `convert from/SGD to/INVALID_CURRENCY v/VALUE` where `INVALID_CURRENCY` is not a supported currency. +
   Expected: Error details shown in status message.
.. Test case: `convert from/INVALID_CURRENCY to/USD v/VALUE` where `INVALID_CURRENCY` is not a supported currency. +
   Expected: Error details shown in status message.

=== Finding a transaction

. Looking up transactions that have the supplied keywords in its `**Remark**` and `**Description**` fields.

.. Test case: `find Apple`. +
    Expected: Transactions with the word 'Apple' in its `**Remark**` or `**Description**` field will be displayed to the user.

=== Undoing the previous command

. Undoing previous command and reflecting changes in the list

.. Prerequisites: List all transactions using the `list` command
.. Test case:
+
--
... `add expense n/Chicken rice v/3`
... `undo`
--
+
Expected: Transaction regarding to the expense spent on chicken rice is removed from the list.
.. Test case:
+
--
... `add income n/Salary v/2500`
... `undo`
--
+
Expected: Transaction regarding to the income received from salary is removed from the list.
.. Test case:
+
--
... `delete 1`
... `undo`
--
+
Expected: First transaction removed from the list is restored back to its original position.
.. Test case: (Assuming that the first transaction is `1. [-] Chicken rice ($3.00)`)
+
--
... `update i/1 n/Fried Rice`
... `undo`
--
+
Expected: The description of the first transaction is changed back to chicken rice.
.. Test case:
+
--
... `clone i/1`
... `undo`
--
+
Expected: Newly cloned transaction is removed from the list.
.. Test case:
+
--
... `tag i/1 t/LUNCH`
... `undo`
--
+
Expected: Lunch tag is removed from the first transaction in the list.
.. Test case:
+
--
... `untag i/1 t/LUNCH`
... `undo`
--
+
Expected: Lunch tag is added back to the first transaction in the list.
.. Test case:
+
--
... `list`
... `undo`
--
+
Expected: No changes. Message shown in the status message indicating that there are no available commands for user to undo.

=== Redoing the undone command

. Redoing undone command and reflecting changes in the list

.. Prerequisites: List all transactions using the `list` command
.. Test case:
+
--
... `add expense n/Laksa v/3`
... `undo`
... `redo`
--
+
Expected: Transaction regarding to the expense spent on Laksa is added back to the list.
.. Test case:
+
--
... `add income n/bursary v/2500`
... `undo`
... `redo`
--
+
Expected: Transaction regarding to the income received from bursary is added back to the list.
.. Test case:
+
--
... `delete i/1`
... `undo`
... `redo`
--
+
Expected: First transaction removed from the list.
.. Test case: (Assume that the first transaction is `1. [-] Chicken rice ($3.00)`)
+
--
... `update i/1 n/Fried Rice`
... `undo`
... `redo`
--
+
Expected: The description of the first transaction remains as fried rice.
.. Test case:
+
--
... `clone i/1`
... `undo`
... `redo`
--
+
Expected: Newly cloned transaction is added back to the list.
.. Test case:
+
--
... `tag i/1 t/FOOD`
... `undo`
... `redo`
--
+
Expected: Food tag is added back to the first transaction in the list.
.. Test case:
+
--
... `untag i/1 t/FOOD`
... `undo`
... `redo`
--
+
Expected: Food tag is removed from the first transaction in the list.
.. Test case:
+
--
... `untag i/1 t/LUNCH`
... `undo`
... `clone i/1`
... `redo`
--
+
Expected: No changes. Message shown in the status message indicating that there are no available commands for user to redo.
.. Test case:
+
--
... `list`
... `redo`
--
+
Expected: No changes. Message shown in the status message indicating that there are no available commands for user to redo.

=== Showing help window

.. Test case: `help` +
   Expected: A new pop-up help window is displayed.
.. Test case: `help delete` +
   Expected: Syntax of the `delete` command is shown in the status message.

=== Saving data

. Dealing with missing/corrupted data files

.. Delete the data file at `.\data\thrift.json`.
