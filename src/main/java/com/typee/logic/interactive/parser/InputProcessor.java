package com.typee.logic.interactive.parser;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.typee.commons.core.Messages;
import com.typee.logic.interactive.parser.exceptions.ParseException;

/**
 * Processes input {@code Strings} to find prefixes and command words.
 */
public class InputProcessor {

    private static final String REGEX_PATTERN_COMMAND_WORD = "[a-zA-Z]+";
    private static final String REGEX_PATTERN_PREFIX = "[a-z]/";
    private static final String MESSAGE_DUPLICATE_PREFIX = "Invalid input. You've entered duplicate prefixes!";

    /**
     * Extracts and returns the list of prefixes in the user entered input.
     * Returns the prefixes in their order of appearance.
     *
     * @param commandText User entered input.
     * @return array of prefixes in their order of appearance.
     * @throws ParseException If prefixes are duplicated.
     */
    public Prefix[] extractPrefixes(String commandText) throws ParseException {
        Pattern pattern = Pattern.compile("[a-zA-z]/");
        Matcher matcher = pattern.matcher(commandText);
        List<Prefix> prefixes = getMatches(matcher);
        disallowDuplicatePrefixes(prefixes);

        // Convert to an array to allow the values to be processed by varargs.
        return prefixes.toArray(Prefix[]::new);
    }

    /**
     * Returns the list of prefixes matched by the input regular expression {@code Matcher}.
     *
     * @param matcher {@code Matcher} containing a text input and a regular expression {@code Prefix} format to match.
     * @return list of matched prefixes.
     */
    private List<Prefix> getMatches(Matcher matcher) {
        List<Prefix> prefixes = new ArrayList<>();
        while (matcher.find()) {
            prefixes.add(new Prefix(matcher.group()));
        }
        return prefixes;
    }

    /**
     * Checks the input list of prefixes to ensure that no duplicates are present.
     *
     * @param prefixes List of prefixes.
     * @throws ParseException If duplicates are present.
     */
    private void disallowDuplicatePrefixes(List<Prefix> prefixes) throws ParseException {
        HashSet<Prefix> setOfPrefixes = new HashSet<>();
        setOfPrefixes.addAll(prefixes);
        if (setOfPrefixes.size() < prefixes.size()) {
            throw new ParseException(MESSAGE_DUPLICATE_PREFIX);
        }
    }

    /**
     * Returns the command word contained in a text input.
     *
     * @param commandText User entered input.
     * @return command word.
     * @throws ParseException If there is no unique command word in the text input.
     */
    public String getCommandWord(String commandText) throws ParseException {
        String trimmedCommandText = commandText.trim();
        List<String> commandWords = getAllCommandWords(trimmedCommandText);

        // If there is no unique command word, throw an exception.
        if (commandWords.size() != 1) {
            throw new ParseException(Messages.MESSAGE_UNKNOWN_COMMAND);
        }

        return commandWords.get(0);
    }

    /**
     * Returns the list of command words present in a {@code String}.
     *
     * @param trimmedCommandText Trimmed text input.
     * @return list of command words.
     */
    private List<String> getAllCommandWords(String trimmedCommandText) {
        int boundary = findBoundary(trimmedCommandText);
        Pattern pattern = Pattern.compile(REGEX_PATTERN_COMMAND_WORD);
        Matcher matcher = pattern.matcher(trimmedCommandText.substring(0, boundary));
        List<String> commandWords = new ArrayList<>();
        while (matcher.find()) {
            commandWords.add(matcher.group());
        }
        return commandWords;
    }

    /**
     * Finds and returns the index of the first {@code Prefix} that appears in the input {@code String}.
     * Returns the length of the {@code String} if no {@code Prefix} is present.
     *
     * @param trimmedCommandText Trimmed text input.
     * @return index of the first {@code Prefix}.
     */
    private int findBoundary(String trimmedCommandText) {
        Pattern pattern = Pattern.compile(REGEX_PATTERN_PREFIX);
        Matcher matcher = pattern.matcher(trimmedCommandText);
        boolean prefixExists = matcher.find();
        if (prefixExists) {
            return matcher.start();
        }
        return trimmedCommandText.length();
    }

}
