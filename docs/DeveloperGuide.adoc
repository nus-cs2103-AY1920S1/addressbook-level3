= StudyBuddy Pro Level 3 - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-W13-3/main

By: `Team AY1920S1-CS2103T-W13-3`

== Introduction

Welcome to StudyBuddy Pro!

StudyBuddy Pro is a desktop-based application with a Graphical User Interface (GUI). It is intended for students in the School of Computing at National University of Singapore (NUS) who prefer to work with a Command Line Interface (CLI).

StudyBuddy Pro aims to lessen target users' revision time consumption without compromising the quality of studies. The application provides a centralized platform for them to revise using flashcards, take notes and generate cheatsheets.

This Developer Guide (DG) is written for anyone who wishes to contribute to our project. In here, you will find StudyBuddy Pro's information for set-ups, its architectures and its key features.

If you wish to know more details about StudyBuddy Pro, please do not hesitate to contact us!

=== Callouts Signs

Do refer to the signs below that will be used across the documents for references. These will prove to be useful when you are reading this document.

[WARNING]
====
Indicates information that are to be adhere as potential problems may be encountered if you are not careful.
====


[IMPORTANT]
====
Indicates information that are crucial to understand so that you will be able to follow the flow of the document. Confusion may arise if you do not grasp the information here.
====

[NOTE]
====
Indicates information that are note-worthy. Do read them for more information and better understandings.
====

[TIP]
====
Indicates additional information that are helpful. Fret not, tips can be good to know but are not vital.
====

=== Syntax

Do refer to _Table 1_ below for the various syntax that will be used across the documents for references. These will prove to be useful when you are reading this document.

.Syntax Table
[options = "header"]
|===
| Syntax | Usage
| *`exampleCommand`*  | Indicates technical terms like _commands_, _classes_ and _methods_
| link:#1[link] | Indicates internal/external links
|===

These syntax will be used in any context across the document. Possible places that they may appear are in _examples_, _explanations_ and _descriptions_. Take note of these syntax as they may have different meaning compared to normal texts!

For example, `switch` is a command for you to type in the CLI so that the function can be executed. However, 'switch' in plain text can mean the switch device itself or to switch amongst some things.

====
An example of `switch` versus 'switch':

- ... `switch` to toggle between the features ...
- ... is able to switch between features ...
====

== Setting up

Do refer to the guide <<SettingUp#, here>> to set up our StudyBuddy Pro on your device(s)!

== Design

The following sections will show how StudyBuddy Pro is being constructed in details.

[[Design-Architecture]]
=== Architecture

The _figure 1_ below displays the high-level design of our StudyBuddy Pro.

.Architecture Diagram
image::ArchitectureDiagram.png[]

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

The architecture diagram describes the relationships between the components, and here is a quick overview of each component:

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component in _Figure 2_ defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

The `logic` component's class diagram shows the relationships between the components it interacts with. Also, it provides the flow of the actions with arrows.

[discrete]
==== How the application modes works?

The _StudyBuddy Pro_ application has 3 modes for all the features: Flashcard, Cheatsheet and Notes.
The users use `switch` command to switch between the modes.
In each mode, the users will interact with only the modes' commands, unless it is a _global_ command.

- `switch fc` - switches to flashcard mode
- `switch cs` - switches to cheatsheet mode
- `switch notes` - switches to notes mode

The following _figure 3_ is an activity diagram that describes the execution of the `switch` command.

.Activity Diagram of `Switch` command execution
image::jasmineDiagrams/SwitchActivityDiagram.png[]

From the activity diagram above, it shows the logic flow of the actions taken when user executes the `switch` command. Also, it shows the checks taken placed to verify the command that was parsed.

[discrete]
==== How the architecture components interact with each other

The _figure 4_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

[IMPORTANT]
====
Assuming that the user is currently in the _flashcard_ mode.
====

.Sequence diagram of component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The above sequence diagram illustrates the relationships between each components in the StudyBuddy Pro's architecture. The sections below will give more details of each of those components.

[[Design-Ui]]
=== User Interface (UI) component

This section describes the behaviour of the `UI` component in details.
The _figure 5_ below portrays the internal structures of the `UI` components and their interactions.

.Class diagram of the structure of the `UI` Component
image::UiClassDiagram.png[]

The class diagram above draws out the relationships between the internal components and their flow of actions.
The segment below provides more details of the `UI` components and its API's link.

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `ActivityWindow`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

This section describes the behaviour of the `logic` component in details.
The _figure 6_ below portrays the internal structures of the `logic` components and their interactions.

[[fig-LogicClassDiagram]]
.Class diagram of the structure of the `logic` Component
image::LogicClassDiagram.png[]

The class diagram above draws out the relationships between the internal components and their flow of actions.
The segment below provides more details of the `logic` components and its API's link.

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `StudyBuddyParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a cheatsheet).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

The _figure 7_ below is the sequence diagram for the interactions within the `Logic` component for the `execute("delete 1")` API call.

[IMPORTANT]
====
Assuming that the user is in the _flashcard_ mode.
====

.Sequence diagram for the interactions Inside the `logic` Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

[IMPORTANT]
====
The lifeline for `DeleteFlashcardCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.
====

The above sequence diagram clearly portrays the execution of the `delete 1` command with relevant _methods_ being called. Also, it provides the action flow and _return variables_ accordingly.

[[Design-Model]]
=== Model component

.Structure of the Model Component

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the StudyBuddyBook data.

[[Design-Storage]]
=== Storage component

This section describes the behaviour of the `storage` component in details.
The _figure 8_ below portrays the internal structures of the `storage` components and their interactions.

.Class diagram of the structure of the `Storage` Component
image::StorageClassDiagram.png[]

The class diagram above draws out the relationships between the internal components and their flow of actions.
The segment below provides more details of the `storage` components and its API's link.

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the StudyBuddyBook data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.studybuddy.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

=== Tagging Feature

==== Implementation

** The current implementation of StudyBuddyItems in StudyBuddyPro is such that it contains a Set of Tags.
** The following objects of each individual feature shares similar Tagging behaviour, as shown in the class diagram below.

image::kaibindiagrams/TaggingFeatureClassDiagram.png[]

==== Design Considerations

** As explained in the class diagram above, each StudyBuddyItem is limited to a total number of 10 tags.
** It is designed as such to prevent users from over-cluttering the result display when they view items that have too many tags.
** To reduce confusion for the user, all tags will be converted to lower-case upon initialization.

==== Usage of Tags

** Inside each feature
*** The user is able to specify a tag name to get a list view of all the items with that specified tag in the mode they are currently in (e.g. `list tag/cs2100`).
** Using Tags globally
*** The user is also able to indicate a tag name get a list view of all the StudyBuddyItems across all 3 modes in StudyBuddyPro.
** Currently, the user is able to specify multiple tags in his/her query.
** The sequence diagram below shows how listing all items across StudyBuddyPro by a specified tag works.

image::kaibindiagrams/ListAllByTagSequenceDiagram.png[]

==== [Proposed] Future improvements

** Supporting deletion of Tags
*** Allow the user to delete a specified Tag.
*** All StudyBuddyItems must be updated in response to the deletion.
*** A proposed implementation would be to store all Tags in a Global Data Structure, and have each StudyBuddyItem reference to that Data Structure.
*** As such, we can apply an Observer pattern to update each StudyBuddyItem upon deletion of a tag.

** Supporting statistics for Tags
*** Display a list of all Tags, with each Tag displaying the amount of Flashcards, Notes, CheatSheets there are.

=== Auto-generated cheatsheet with customizable contents feature

[NOTE]
All the operations assume the user is in the _cheatsheet_ mode.

==== Implementation

This feature has a two-step implementation.
The first step is to auto-generate cheatsheet, and the second step is to enable removal of contents in the generated cheatsheet.

===== Step 1: Auto-generation

The auto-generation mechanism is used in the `AddCheatSheetCommand` during creation of the cheatsheet.
After creation, the cheatsheet is then stored in the `studyBuddy` storage.

It is involved in the following operations:

- `AddCheatSheetCommand#execute()` -- Creates the cheatsheet

- `AddCheatSheetCommand#getRelevantContents()` -- Gets all the contents from _flashcard_ and _notes_ according to the _tags_ specified

The first operation is exposed in the `Model` interface as `Model#setCheatSheet()`.

The following sequence diagram shows how the auto-generation operation works:

image::jasmineDiagrams/AddCheatSheetSequenceDiagram.png[]

===== Step 2: Customizing contents

The customization is based on the contents that the user wants to remove.

The auto-generation mechanism is used in
the AddCheatSheetCommand during creation of the cheatsheet.
After creation, the cheatsheet is then stored in the studyBuddy storage

==== Design Considerations
===== Aspect:

* **Alternative 1 (current choice):**
** Pros:
** Cons:
* **Alternative 2:**
** Pros:
** Cons:

==== [Proposed] Future improvements

=== Flashcards Time Trial Feature

==== Implementation
a.	The time trial mechanism is facilitated by the `FlashcardTabWindowController`, and mainly uses the `Timeline`, `KeyFrame` and `KeyValue` class from the JavaFX package to support its functionality.

image:: To be added

b.	Given below is an example usage scenario and how the time trial mechanism behaves at each step.
c. Upon initialization of the StudyBuddy and switching to the Flashcard window, the StudyBuddyParser’s function enum will be set to parse ‘Flashcard’ commands.
d.	The user executes (timetrial cs2100), and the StartTimeTrialCommand retrieves a List of flashcards with the associated tag through the Model#getTaggedFlashcards, which is then passed into the FlashcardTabWindowController.
e.	The FlashcardTabWindowController then calls the FlashcardTabWindowController#startTimeTrial, which in turns construct a timeline with the following added for 3 flashcards:
1.	A KeyFrame to call the FlashcardTabWindowController #loadTimeTrial method, which displays the question of the flashcard on the window, with a KeyValue that starts the timer on the screen.
2.	A KeyFrame to call the FlashcardTabWindowController#showFlashcardAns method, which hides the Timer and flashes the answer of the flashcard for a set period of time.
3.	A KeyFrame is then added to the timeline to call the FlashcardTabWindowController#resetViews method, which in turn empties the qnsTextArea and ansTextArea. [TO BE REFORMATTED]

==== Design Considerations
===== Aspect: How the timetrial is implemented

* **Alternative 1 (current choice):** 1.	Using the `TimeLine` class to set the timer
object.
** Pros: Tidier and easier to understand.
** Cons: Have to read up on the API and learn about the relevant classes such as `KeyFrame` and `KeyValue`
* **Alternative 2:** Looping Thread.sleep() to set the timer
** Pros: Easier to implement
** Cons: Code will be messier and harder to read

===== Aspect: How to continue the time trial

* **Alternative 1 (current choice): Each flashcard and its’ respective answer is displayed for a set period of time before the next flashcard**
** Pros: Easier to implement
** Cons: Inflexible as user can only view the answer for a set amount of time
* **Alternative 2:** Allowing users to input commands to display the flashcard answer / move on to the next flashcard
** Pros: Better flow of time trial feature and improved user experience
** Cons: Hard to implement

==== [Proposed] Future improvements
** Allowing users to set their own time limit for each flashcard in the time trial mode
*** Command will be inputted to set the duration of the timer for each flashcard
** Allowing users to decide when to move on to the next flashcard
*** Question will still be shown for a fixed period of time, but a command will be required to move on to the next flashcard instead of just flashing the answer for a set amount of time

=== Remind Flashcard Feature

{To be completed soon}

==== Implementation
The  remind feature is facilitated by ``

image::remindDiagrams/RemindFeatureRelevantClassDiagram.png[]

==== Design Considerations
===== Aspect: Implementation of utility attributes or classes to keep track of number of times a `Flashcard` object was
viewed.

* **Alternative 1 (current choice):** Design a new `ViewCount` class and make a `Flashcard` object store a `ViewCount`
object.
** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons:
* **Alternative 2:** Use an integer attribute field in `Flashcard` object
** Pros: Easier to maintain: The addition of a new class increases overall coupling compared to adding a single new
attribute.
** Cons: Bad OOP practice and makes it difficult to implement future changes

===== Aspect:

* **Alternative 1 (current choice):**
** Pros:
** Cons:
* **Alternative 2:**
** Pros:
** Cons:

==== [Proposed] Future improvements
** Improved formula for reminding
*** Take into account other factors such as user confidence level or number of times flashcard was answered correctly
or incorrectly to create a more dynamic reminding schedule.

** Link to `exit` command
*** Checks if the user viewed all flashcards to be revised on the day.
*** If some of the relevant flashcards were not viewed, reminds user about remaining flashcards and stalls
application exit.
*** User can either go back into StudyBuddy and view the relevant flashcards or supply an `exit` command again to
close the application.

** More statistics for motivation
*** Tracks how often user viewed flashcards on time and how many flashcards users missed viewing on the relevant
deadline.
// end::remind[]

=== Note feature

Notes are used in the creation of CheatSheet objects as well as in general use of StudyBuddyPro.

==== Implementation

[NOTE]
All the operations assume that the user is in the _notes_ mode.

Notes contain a Title and some Content, with optional Tags, as shown in the diagram below:

image::samDiagrams/NoteModelClassDiagram.png[]

==== Usages of Notes

Notes can be used to:

** Store information under a title
** Categorize information via the use of Tags
** Provide information to CheatSheets for collation

Notes can currently be:

** Added to StudyBuddyBook
** Deleted from StudyBuddyBook
** Viewed from StudyBuddyBook
** Viewed with filter from StudyBuddyBook

The sequence diagram below describes the calls within the Model component upon the addition of a Note object:

image::samDiagrams/AddNoteSequenceDiagram.png[]

The two main steps of the process are:

** The parsing of a Command from the input String
** The execution of the Command which alters Model

==== [Proposed] Note content tagging feature

The proposed feature involves the application of tags within the Note content.

===== Design Implementation

This feature can be achieved by:

** Including a user-inputted tag within portions of the Note content
** Parsing for this content tag when filtering by tag
** Listing these content fragments upon filtering by tag

===== Usages of feature

** More precise inclusion of tags when creating CheatSheet objects
** Ability to nest tags inside each other

== Documentation

Please do refer to the guide <<Documentation#, here>> for more information about this section!

== Testing

Please do refer to the guide <<Testing#, here>> for more information about this section!

== Dev Ops

Please do refer to the guide <<DevOps#, here>> for more information about this section!

== Appendixes

The following sections will be titled as '_Appendix_' followed by an alphabet in alphabetical order to denote the different appendixes.
The following is an example of an appendix heading.

*Appendix Z: ABC*

- Alphabet 'Z' indicates its placing in the order of appendixes
- Phrase 'ABC' indicates the title of the appendix

[appendix]
== Product Scope

*Target user profile*:

* is a Computer Science major student in NUS
* is a visual learner that benefits from using flashcards
* can benefit from better organization of notes
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: integrate flashcards and note compilers for CS students better than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *` |user |have as much information on hand as possible |get all the information I have collected and tagged as part of my revision and ensure that I have all the necessary information at hand.

|`* * *` |user |save time in creating cheatsheet | spend more time on revision

|`* * *` |user |tailor the information I have in my cheatsheet |choose which types of tags I want to include in my cheatsheet.

|`* * *` |user |familiarise with some common programs from the pre-set flashcards in the question bank |learn more useful tips and snippets of information

|`* * *` |user |quickly store tutorial questions for revision |just store a screenshot of the question for future reference

|`* * *` |user |lighten the weight of my bag |cure my back pain from carrying a heavy bag and still store my notes conveniently.

|`* * *` |user |find my notes efficiently for reference |write as much notes as possible during studies without worries

|`* * *` |user who constantly misplace notes |keep myself more organized |effectively see what notes are missing

|`* * *` |user |sort and skim through long lists of notes quickly |take notes during class without missing out important pointers

|`* * *` |user |take charge of my learning by having multiple “filters” or “levels” to my learning |be a proactive learner

|`* * *` |user who is forgetful |practice spaced retention |better memorize and recall the topics

|`* * *` |user |better understand or memorize the topics |improve my results

|`* * *` |university educator teaching multiple modules |easily categorize and organize the notes I create for my students |easily search by the tags for relevant notes

|`* *` |user |make cheatsheets from exams |organize and collate the best pointers to be made into a cheatsheet

|`* *` |user |creatively create and implement notes |be more effective with my studies

|`* *` |user |not take break for too long |be effective with my revision using the pomodoro technique

|`* *` |user |have suggestions on what to do during breaks | be more productive and on-track with tasks

|`* *` |user |make sure that my notes doesn’t miss out important points |collate and compare my notes with my friends’ efficiently

|`* *` |user |be reminded at appropriate times to revise my work |revise regularly and consistently

|`* *` |user |disseminate information efficiently |save the work amongst different teammates

|`* *` |user |better understand or memorize the topics |improve my results

|`* *` |user |connect different parts of questions together | easily link concepts together

|`* *` |user |share notes with my friends and for them to share notes with me, for ease of discussion |be able to study with others

|`* *` |user |answer the questions within a certain time frame |boost my confidence and proficiency in a subject

|`* *` |user |keep track of the harder questions |revise more effectively

|`* *` |university educator |keep track of my students' progress and evaluate who are the stronger/weaker students so they can help each other |help my students do well in their studies

|`* *` |university educator |distribute the flashcards I create to my students so they can use them to practice |help my students better memorise and recall my class content

|`* *` |university educator |give my students quizzes during lecture using the flashcards | make sure that they will not fall asleep during lecture.

|`*` |user |download flashcards from online sources |save time for other revisions

|`*` |user |create notes without papers | save the earth

|=======================================================================

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `StudyBuddy` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== *User story 1:*
As a student who is busy with revision and has no time to create a cheatsheet, the cheatsheet
generation feature will help me save time on creating cheatsheets and let me spend more time on revision.

[discrete]
=== Use case: UC01 – Create a cheatsheet

Preconditions: StuddyBuddy application is opened

*MSS*

1.	User navigates to cheetsheat section.

2.	User chooses to create new cheatsheet.

3.	StuddyBuddy asks user for new cheatsheet’s title.

4.	User inputs new cheatsheet’s title.

5.	StuddyBuddy asks user for new cheatsheet’s module.

6.	User inputs new cheatsheet’s module.

7.	StuddyBuddy asks for new cheatsheet’s tags.

8.	User inputs new cheatsheet’s tags.
+
Use case ends

[discrete]
=== Use case: UC02 – List cheatsheets

Preconditions: StuddyBuddy application is opened

*MSS*

1.	User navigates to cheetsheat section.

2.	User chooses to list all cheatsheet.

3.	StudyBuddy displays all cheatsheets.
+
Use case ends.

[discrete]
=== Use case: UC03 – Edit a cheatsheet

Preconditions: StudyBuddy application is opened, User knows cheatsheet ID

*MSS*

1.	User navigates to cheetsheat section.

2.	User chooses to edit cheatsheet.

3.	StudyBuddy asks for cheatsheet ID for cheatsheet to be edited.

4.	User inputs cheatsheet ID.

5.	StudyBuddy asks for parameters to be edited.

6.	User inputs perimeters to be edited.

7.	StudyBuddy displays edited cheatsheet.
+
Use case ends.

[discrete]
=== Use case: UC04 – View a cheatsheet

Preconditions: StudyBuddy application is opened, User knows cheatsheet ID

*MSS*

1.	User navigates to cheetsheat section.

2.	User chooses to view cheatsheet.

3.	StudyBuddy asks for cheatsheet ID for cheatsheet to be viewed.

4.	User inputs cheatsheet ID.

5.	StudyBuddy displays cheatsheet.
+
Use case ends.

=== Use case: User story 1

*MSS*

1.	User _creates cheatsheet (UC01)_.

2.	User _views cheatsheet (UC04)_.
+
Use case ends.

*Extensions*

* 2a. User chooses to edit cheatsheet.
+
2a1. User _edits cheatsheet (UC03)_.

{Fix indent}

+
Use case ends.

[discrete]
=== User story 2:
As a student who finds it very cumbersome to store tutorial questions that I would like to revise, I can make use of the flashcard function to just store a screenshot of the question for future reference.

[discrete]
=== Use case: UC05 – Create a flashcard from image
Software system: StudyBuddy, OS

Preconditions: StudyBuddy application is opened

*MSS*

1.	User finds a tutorial question he/she would like to revise.

2.	User takes screenshot of tutorial question.

3.	OS asks user where screenshot should be saved.

4.	User saves screenshot in designated StudyBuddy image folder with custom name.

5.	User opens StudyBuddy application.

6.	User navigates to flashcard section.

7.	User chooses to create new flashcard from image source.

8.	StudyBuddy asks user for file name.

9.	User inputs file name.

10.	StudyBuddy asks user for flashcard’s answer.

11.	User inputs flashcard’s answer.

12.	StudyBuddy asks user for flashcard’s title.

13.	User inputs flashcard’s title.

14.	StudyBuddy asks user for flashcard’s module.

15.	User inputs flashcard’s module.

16.	StudyBuddy displays created flashcard.
+
Use case ends.

*Extensions*

* 15a. User wants to input additional flashcard hint.

15a1. User inputs flashcard’s hint.

{Todo markup indent}

+
Use case resumes from step 16.

* 15b. User wants to input additional flashcard tags.

15a2. User inputs flashcard’s tags.

{Todo markup indent}

+
Use case resumes from step 16.

* 15c. User wants to input additional hint and tags.

15c1. User inputs flashcard’s hint.

15c2. User inputs flashcard’s tags.

{Todo markup indent}

+
Use case resumes from step 16.

[discrete]
=== Use case: UC06 – Start <<time-trial,time trial>>

*MSS*

1.	User navigates to flashcard section.

2.	User chooses to start time trial.

3.	StudyBuddy asks user for time per flashcard.

4.	User inputs time per flashcard.

5.	StudyBuddy asks user for tags to select flashcards for inclusion.

6.	User inputs tags.

7.	StudyBuddy starts time trial with specified parameters.
+
Use case ends.

[discrete]
=== Use case: User story 2

*MSS*

1.	User _creates flashcards from image (UC05)_ with tag “tutorial questions”.

2.	User _starts time trial (UC06)_ with tag “tutorial questions”.
+
Use case ends.

{Todo delete later}

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. StudyBuddyBook shows an error message.
+
Use case resumes at step 2.

_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  A flashcard cannot have more than 10 tags.
.  The product is not required to confirm if the user has answered the flashcard correctly. Instead, the product lets the user checks the answer and determine himself/herself if he/she has answered it correctly.
.  The in-built flashcard library is expected to be updated annually, to follow the curriculum of NUS computing modules.
.  The command-line syntax should prioritise user-friendliness.

_{More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[flash-card]] FlashCard::
A titled digital 'card' that contains a question (image or text), answer, as well as it's relevant tags.

[[cheat-sheet]] Cheatsheet::
A document that contains the notes the user has specified during creation

[[time-trial]] Time-Trial::
A mode of answering flashcards in which you must provide the answer within a designated time period.


[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_

