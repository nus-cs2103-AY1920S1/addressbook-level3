= IchiFund - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-W12-4/main
:drawioURL:

image::logo.png[align="center"]

By: `Team AY1920S1-CS2103T-W12-4`      Since: `Sep 2019`      Licence: `MIT`

== Introduction

IchiFund is a financial tracking application that manages transactions, loans, as well as budgets.

Shown below is the GUI of IchiFund:

image::Ui.png[]

This document serves to give an introduction to the architecture of IchiFund for developers who wish to
modify the software, or simply to understand how it works. We describe the high-level architecture, and also delve into
important details of the implementation of each feature.

== Setting Up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.drawio` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
To edit, go to {drawioURL} and import the `.drawio` files in the repository.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/ichifund/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/ichifund/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI Component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/ichifund/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `TransactionListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/ichifund/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.
* Listens for changes to the index of the `FeatureParser` used by the `Logic` component to change tabs.
* Sets the `FeatureParser` used by the `Logic` component when the user manually changes tabs.

[[Design-Logic]]
=== Logic Component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/ichifund/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `IchiFundParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

[[Design-Model]]
=== Model Component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/ichifund/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the IchiFund data (in e.g. `UniqueBudgetList`)
* keeps track of a `TransactionContext` object that represents the current filter applied to `TransactionList`.
* exposes an unmodifiable version of the `TransactionContext` object (as `ObservableValue<TransactionContext>`) that can be observed by the UI.
* exposes unmodifiable lists (e.g. `ObservableList<Transaction>`) that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

image:ModelClassDiagram.png[]

[[Design-Storage]]
=== Storage Component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/ichifund/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the IchiFund data in json format and read it back.

[[Design-Commons]]
=== Common Classes

Classes used by multiple components are in the `seedu.ichifund.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== Global Features

// tag::tabswitching[]
==== Separate Parsing and Tab Switching
In IchiFund, we separate the features by tabs. This is illustrated in the image below, which displays the five
tabs of IchiFund, with the "Transaction" tab selected:

[[fig-FeatureTabs]]
.Feature Tabs in IchiFund
image::FeatureTabs.png[]

The parsing of commands for each feature is done separately, tied to their respective tabs.
In other words, the commands specific to each feature can only be recognised when the feature is selected as the
current tab.
This allows for the overloading of commands across different features, reducing the complexity of commands for users.

===== Implementation
There are two aspects to consider in implementing separate parsing:

* Detecting when the user switches tabs and communicating this to the `Logic` component
* Determining how to parse commands on the end of `Logic` given which tab is selected.

In our implementation, we first separate the parsing of commands for different features by delegating them to their
respective `FeatureParser` parsers. The main parser, `IchiFundParser`, keeps track of all `FeatureParser` objects, as
well as the `FeatureParser` that is currently in use.

This is illustrated in the object diagram below:

image::ParserObjectDiagram.png[]

When `IchiFundParser` parses a command, it first checks whether it is a global command (e.g. `help`, `exit`).
Otherwise, it passes the command to `currentParserManager`, which checks if it is a valid command, and passes the
arguments to the appropriate `Parser`.

What remains is determining when to change `currentParserManager`. Here, we support 3 modes of tab switching:

1. Specific commands (CLI)

Users can switch between tabs using specific commands (`tx`, `rep`, `budget`, `loan`, `analytics`).

These commands are global commands that are directly recognised by `IchiFundParser`, which changes
`currentFeatureParser` and the index stored.

Much like the `Model` data, `MainWindow` listens to changes to the index through `FeatureParserIndexListener`.
Whenever the value of the index changes, the listener triggers an event to change the tab throw the `invalidated()`
method shown in the code snippet below:

image::ListenerCodeSnippet.png[]

The `InvalidationListener` constructed from the above code is added to an `ObservableValue` in `MainWindow`
that tracks the index of the current `FeatureParser` used, and changes to the appropriate tab using
the value of the index stored.

[start = 2]
1. Shortcut keys (GUI)

Users can also switch tabs using the shortcut keys `Ctrl + 1` to `Ctrl + 5`. Upon using the shortcut keys,
the following handler is triggered:

image::MainWindowShortcutKeyCodeSnippet.png[]

When `handleShowTransaction()` is called, `currentFeatureParser` in `IchiFundParser`, is set to
`TransactionFeatureParser`, which has a `tabIndex` of zero. Other handler methods are similar to
`handleShowTransaction`, with the only difference being the index passed to `Logic`.

The control flow of `handleShowTransaction()` is illustrated with more details in the sequence diagram below:

image::SetFeatureParserSequenceDiagram.png[]

As the different `FeatureParser` objects have different values for `tabIndex`, a different
index is passed, and a different `FeatureParser` is set as `currentFeatureParser`.

[NOTE]
After the handler method is run, the change in `IchiFundParser` is also detected by
`InvalidationListener`, which results in a tab switch similar to how the specific commands would.

[WARNING]
For developers who wish to add more features to IchiFund, care has to be taken in ensuring that the indices of the
`FeatureParser` objects matches that of the tabs, as well as its index in `featureParsers`.
In our current implementation, we do not use enum for the indices due to the small scale of usage.

[start = 3]
1. Clicking of tabs (GUI)

Users can switch tabs by clicking on the tabs shown in <<fig-FeatureTabs>>.
This triggers a handler, shown in the following code snippet:

image::MainWindowMouseCodeSnippet.png[]

The control flow for this handler is similar to that of the shortcut keys.

===== Design Considerations

In designing the specific commands for tab switching, we considered an alternative implementation for
passing information about tab switching to `Ui`.

[options='header']
|====================
| Description of Implementation | Pros and Cons
| `Ui` detects change through an `InvalidationListener` (current choice) |
*Pros*: `Logic` does not need to be aware of `Ui`.

*Cons*: Requires greater understanding of JavaFX API to implement.

| `Logic` directly calls `Ui` whenever the specific command is made. |
*Pros*: Easy to implement.

*Cons*: Creates a dependency from `Logic` to `Ui`.
|====================

While Alternative 2 is much simpler to implement, we chose Alternative 1
as we prioritised preserving the independence of `Logic` from `Ui`.

// end::tabswitching[]

// tag::tasks[]
==== Tasks
Some models in IchiFund must be refreshed after a command is executed.
For instance, when a new `Transaction` is added, all `Budget` must be recomputed.
`Task` can be used to facilitate such updates.

===== Implementation
This feature is managed by `TaskManager`.
The role of `TaskManager` is to maintain a list of all active `Task`.

The `LogicManager` holds an instance of the `TaskManager`.
When the `LogicManager#execute()` is called, the following chain of operations occurs:

1. After `Command#execute()` is completed, `TaskManager#executeAll()` is called.

image::TaskCode.png[]

[start=2]
2. `TaskManager#executeAll()` will iterate through all active `Task` and call the respective `Task#execute()` method.
// end::tasks[]

=== Transaction

// tag::overviewtx[]
[[overviewtx]]
==== Overview of Transaction Model

===== Implementation

The transactions in IchiFund are represented using the `Transaction` class. While users are able to edit transactions,
objects of the `Transaction` class are immutable in the internal structure. The following class diagram summarizes
the details of the `Transaction` class:

image::TransactionClassDiagram.png[]

Of note, we differentiate transactions into income and expenditure items using the `TransactionType` field, which accepts
two unique string values, `"in"` for income and `"exp"` for expenditure in the constructor.

In addition, the list of transactions is subject to a filter created by an immutable `TransactionContext`.
`TransactionContext` keeps track of the `Month`, `Year`, `Category` (optional) and `TransactionType` (optional) in the current filter.
Naturally, this implies that a filter for `Month` and `Year` is always applied to the list of transactions.
We defer the demonstration of how `TransactionContext` is used to filter the list of transactions to <<filtertx>>

The `TransactionContext` is also used to fill in optional fields that are not specified by the user when adding transactions.
Later, in <<addtx>>, we demonstrate how this is implemented.

We summarise the role of the `TransactionContext` class in the following conceptual class diagram:

image::TransactionContextOodm.png[]

===== Design Considerations

We encountered two major decisions when implementing our model for transactions. Here, we discuss the alternatives
we considered, as well as the rationale for the current implementation.

====== Multiplicity of `Category`
Currently, each `Transaction` object can have only one `Category` object associated to it. In the problem domain, it is
also natural to think of transactions being associated with multiple categories. The table below summarizes the pros and cons of each choice.
[options='header']
|====================
| Description of Implementation | Pros and Cons
| Each `Transaction` only has one `Category`  (current choice) |
*Pros*: Simple to implement. No overlaps in apportionment of expenditure to categories.

*Cons*: Less flexibility for the user to classify transactions.

| Each `Transaction` can have more than one `Category` |
*Pros*: More flexibility for the user to classify transactions.

*Cons*: Overlaps in apportionment of expenditure to categories.
|====================
While both implementations are visible, we chose to only have one `Category` associated to each
`Transaction` as the absence of overlaps in expenditure allows us to eventually implement a clean visual
breakdown of expenditure by category in the future.

Developers, however, are welcome to implement an additional `Tags` field for `Transaction` objects, to allow
for multiple associations.

====== Differentiating between Income and Expenditure
Currently, we differentiate transactions that are income items and expenditure items using the `TransactionType` field in
`Transaction`. We considered the natural alternative of using inheritance as well.

[options='header']
|====================
| Description of Implementation | Pros and Cons
| Using the field `TransactionType` (current choice) |
*Pros*: Fits the parsing methods used in the current architecture well.

*Cons*: More tedious to code for different behaviours for income and expenditure items in the future.

| Using inheritance |
*Pros*: Allows for polymorphism of methods from a `Transaction` interface in the long run.

*Cons*: Requires either the use of separate commands, or asymmetry in the parsing of command arguments.
|====================
While it was a tough decision, we eventually decided to use `TransactionType` for differentiation as we valued maintaining the
symmetry in the implementation of parsing in our current architecture, and we did not want to use separate commands for adding transactions.

Furthermore, we did not envision further use of polymorphism in future developments. Hence the benefit of using inheritance becomes
very limited.
// end::overviewtx[]

// tag::transfilter[]
[[filtertx]]
==== Filtering Transactions

The filter transactions feature allows the user to change the filter for the list of transactions.
As described in <<Design-Logic>>, this feature is facilitated by `TransactionFeatureParser`, `FilterTransactionCommandParser`, and `FilterTransactionCommand`.
The arguments supported by this feature includes:

- `Month` (optional)
- `Year` (optional)
- `Category` (optional)
- `TransactionType` (optional)

Although all arguments are optional, the user has to input at least one argument for the command
to be valid.

===== Implementation

As prefaced in <<overviewtx>>, the `filter` command interacts with `TransactionContext` to filter the list of
transactions exposed to the UI component.

Following the creation of `FilterTransactionCommand`, the execution of the command results
in the following chain of events:

1. The `FilterTransactionCommand` retrieves the current `TransactionContext` from the model.
2. The `FilterTransactionCommand` creates a new `TransactionContext`, facilitated by `TransactionContextBuilder`
3. The `FilterTransactionCommand` sets the new context in model as the newly created `TransactionContext`.
4. `ModelManager` retrieves a `Predicate<Transaction>` from the new `TransactionContext`.
5. `ModelManager` filters the list of transactions using the `Predicate<Transaction>`.

The above sequence of events is shown in greater detail in the following sequence diagram:
image::FilterTransactionSequenceDiagram.png[]
// end::transfilter[]

// tag::transadd[]
[[addtx]]
==== Adding Transactions

The add transaction feature allows the user to add a transaction into IchiFund. It further ensures that the current
filter of the list of transactions is changed to allow the user to view the transaction.
As described in <<Design-Logic>>, this feature is facilitated by `TransactionFeatureParser`, `AddTransactionCommandParser`, and `AddTransactionCommand`.
The arguments supported by this feature includes:

- `Description`
- `Amount`
- `Category` (optional)
- `Day` (optional)
- `Month` (optional)
- `Year` (optional)
- `TransactionType` (optional)

===== Implementation

As prefaced in <<overviewtx>>, the `add` command interacts with `TransactionContext` to create new `Transaction` objects.

The execution of an `AddTransactionCommand` results in the following sequence of events:

1. The `AddTransactionCommand` retrieves the current `TransactionContext` from the model.
2. The `AddTransactionCommand` generates a new `Transaction` based on the arguments and `TransactionContext`
3. The `AddTransactionCommand` adds the new `Transaction` to the model.
4. `ModelManager` automatically sorts the list of transactions.
5. The `AddTransactionCommand` calls model to execute `updateTransactionContext`
6. `ModelManager` updates `TransactionContext` such that the new `Transaction` is shown.

When generating a new `Transaction`, `AddTransactionCommand` fills in the missing optional arguments by using
values obtained from `TransactionContext`, or default values. This is illustrated in the following activity diagram:

image::AddTransactionActivityDiagram.png[]

The above activity diagram shows the decision flow for a general optional argument. However, some optional
arguments are never stored in `TransactionContext`, and some are always stored in `TransactionContext`. The
following table describes the particular details for each optional argument, including the default values.

[options='header']
|====
| Argument | Present in `TransactionContext`? | Default value
| `Day` | Never | Current day of month from system time
| `Month` | Always | Not applicable
| `Year` | Always | Not applicable
| `Category` | Sometimes | Uncategorised
| `TransactionType` | Sometimes | Expenditure
|====

After adding the `Transaction`, a new `TransactionContext` is created such that the new `Transaction` is displayed
on the list of transactions. Specifically, the `Month` and `Year` filters are set to the `Month` and `Year` of the
new `Transaction` respectively, and the `Category` and `TransactionType` filters are removed if necessary.

===== Design Considerations
In implementing the `add` and `filter` commands, we had to decide on the underlying data structure for the list of
transactions. Currently, we store all transactions in a single iterable list. Given the use of a mandatory
month and year filter, a natural alternative would be to store each month's worth of transactions in a
list, and stores these lists in another list, forming a multi-level list.

[options='header']
|====================
| Description of Implementation | Pros and Cons
| Storing all transactions in a single list (current choice) |
*Pros*: Suits existing architecture of software very well, easy to implement

*Cons*: Slow performance anticipated with large number of transactions

| Storing transactions in multi-level list |
*Pros*: Faster performance, more scalable

*Cons*: May disrupt abstractions in current architecture, more time needed to implement
|====================

Ultimately, we prioritised developing a minimal viable product for v1.4, and decided to avoid disrupting the
existing architecture, and instead focus our efforts on developing more features to better address the needs of
the target user profile.

However, moving forward, we recognise that the current architecture severely lacks scalability,
especially given the constantly growing number of transactions we expect users to create. Hence, we eventually
intend to switch to a multi-level list. Developers who choose to undertake this heavy task need to bear in mind
that many other component (Repeaters, Budget, Analytics) depend on the model of this component, and care must
be taken to ensure that these components still work well.

// end::transadd[]

// tag::transedit[]
==== Editing Transactions

The edit transaction feature allows the user to edit a transaction into IchiFund. It further ensures that the current
filter of the list of transactions is changed to allow the user to view the transaction.
As described in <<Design-Logic>>, this feature is facilitated by `TransactionFeatureParser`, `EditTransactionCommandParser`, and `EditTransactionCommand`.
The arguments supported by this feature includes:

- `Index`
- `Description` (optional)
- `Amount` (optional)
- `Category` (optional)
- `Day` (optional)
- `Month` (optional)
- `Year` (optional)
- `TransactionType` (optional)

===== Implementation

// end::transedit[]

// tag::transdel[]
==== Deleting Transactions

The delete transaction feature allows the user to delete a transaction into IchiFund using its index in the displayed list.
As described in <<Design-Logic>>, this feature is facilitated by `TransactionFeatureParser`, `DeleteTransactionCommandParser`, and `DeleteTransactionCommand`.
The arguments supported by this feature includes:

- `Index`

===== Implementation

The execution of the `delete` command is almost identical to that of the budget deleting command.

// end::transdel[]

=== Repeaters

// tag::repeateradd[]
==== Adding Repeater : `add`

===== Overview
This feature allows the user to add a repeater in IchiFund. Adding a repeater also creates the transactions associated with the added repeater.

===== Implementation
The `addrep` command is facilitated by the Logic and Model components of the application. Given below is an example usage scenario of how `addrep` behaves at each step.

*Step 1*: The user executes `addrep de/Phone bills a/42.15 c/Utilities ty/exp so/3 eo/2 sd/1 sm/1 sy/2019 ed/31 em/12 ey/2019` to add a repeater for phone bills with an amount of $42.15 on the third and second last day of every month between 1st January 2019 and 31st December 2019.

*Step 2*: `LogicManager` uses `IchiFundParser#parserCommand()` to parse the input from the user.

*Step 3*: `IchiFundParser` determines which command is being used and creates the respective `AddRepeaterCommandParser` parser with the user's input as an argument.

*Step 4*: `AddRepeaterCommandParser` does a validation check on the user's input before creating and returning an `AddRepeaterCommand` with desired `Repeater` as an argument.

*Step 5*: `LogicManager` uses `AddRepeaterCommand#execute()` to add the `Repeater` and the associated ``Transaction``s into the `Model` which is handled by `ModelManager`. In doing so, it also fetches the `RepeaterUniqueId` counter tracked by the `Model`, sets it as the created ``Repeater``'s unique id, and increments the counter in the `Model` by 1.

*Step 6*: `AddRepeaterCommand` returns a `CommandResult` to the `LogicManager` which is returned back to the user.
// end::repeateradd[]

// tag::repeaterdelete[]
==== Deleting Repeater : `delete`

===== Overview
This feature allows the user to delete repeater in IchiFund. Delete a repeater also deletes the transactions associated with the deleted repeater.

===== Implementation
The `delrep` command is facilitated by the Logic and Model components of the application. Given below is an example usage scenario of how `delrep` behaves at each step.

*Step 1*: The user executes `delrep 2` to delete the repeater in the 2nd index.

*Step 2*: `LogicManager` uses `IchiFundParser#parserCommand()` to parse the input from the user.

*Step 3*: `IchiFundParser` determines which command is being used and creates the respective `DeleteRepeaterCommandParser` parser with the user's input as an argument.

*Step 4*: `DeleteRepeaterCommandParser` does a validation check on the user's input before creating and returning an `DeleteRepeaterCommand` with desired `Index` as an argument.

*Step 5*: `LogicManager` uses `DeleteRepeaterCommand#execute()` to delete the `Repeater` and the associated ``Transaction``s from the `Model` which is handled by `ModelManager`.

*Step 6*: `DeleteRepeaterCommand` returns a `CommandResult` to the `LogicManager` which is returned back to the user.
// end::repeaterdelete[]

=== Budget

// tag::budgetadd[]
==== Adding Budget

The add budget feature allows the user to add a budget into IchiFund.
This feature is facilitated by `BudgetFeatureParser`, `AddBudgetCommandParser`, and `AddBudgetCommand`.
The arguments supported by this feature includes:

- `Description`
- `Amount`
- `Category` (optional)
- `Month` (optional)
- `Year` (optional)

===== Implementation

When the user input the `add` command in the Budget tab, the following chain of operations occurs:

1. The `IchiFundParser` will delegate the parsing of the command to `BudgetFeatureParser` if the current active tab is Budget.

2. The `BudgetFeatureParser` will delegate the parsing of the arguments to `AddBudgetCommandParser`.

3. `AddBudgetCommandParser#parse()` will take in a `String` input consisting of the arguments.

4. This arguments will be tokenized and the respective models for each argument are created.

5. If the parsing of all arguments are successful, a new `Budget` object is created using the arguments, and a new `AddBudgetCommand` is returned back to `LogicManager`.

6. The `LogicManager` executes `AddBudgetCommand#execute()`.

7. The newly created `Budget` is added to the model.

This process is further illustrated in the following sequence diagram:

.Sequence Diagram for `add` Command under Budget Tab
image::AddBudgetSequenceDiagram.png[]
// end::budgetadd[]

=== Analytics

// tag::analyticsexpenditure[]
==== View Expenditure Trend

The view expenditure trend feature allows the user to view monthly expenditure trend for a year.
This feature is facilitated by `AnalyticsFeatureParser`, `ExpenditureTrendCommandParser`, and `ExpenditureTrendCommand`.
The argument supported by this feature is:

- `Year` (optional)

===== Implementation

When the user input the `expenditure` command in the Analytics tab, the following chain of operations occurs:

1. The `IchiFundParser` will delegate the parsing of the command to `AnalyticsFeatureParser` if the current active tab is Analytics.

2. The `AnalyticsFeatureParser` will delegate the parsing of the arguments to `ExpenditureTrendCommandParser`.

3. `ExpenditureTrendCommandParser#parse()` will take in a `String` input consisting of the arguments.

4. This arguments will be tokenized and the respective models for each argument are created.

5. If the parsing of all arguments are successful, a new `ExpenditureTrendCommand` is returned back to `LogicManager`.

6. The `LogicManager` executes `ExpenditureTrendCommand#execute()`.

7. The model is updated with the `List` of `Data` from the newly created `TrendReport`.
// end::analyticsexpenditure[]

// tag::analyticsincome[]
==== View Income Trend

The view income trend feature allows the user to view monthly income trend for a year.
This feature is facilitated by `AnalyticsFeatureParser`, `IncomeTrendCommandParser`, and `IncomeTrendCommand`.
The argument supported by this feature is:

- `Year` (optional)

===== Implementation

When the user input the `income` command in the Analytics tab, the following chain of operations occurs:

1. The `IchiFundParser` will delegate the parsing of the command to `AnalyticsFeatureParser` if the current active tab is Analytics.

2. The `AnalyticsFeatureParser` will delegate the parsing of the arguments to `IncomeTrendCommandParser`.

3. `IncomeTrendCommandParser#parse()` will take in a `String` input consisting of the arguments.

4. This arguments will be tokenized and the respective models for each argument are created.

5. If the parsing of all arguments are successful, a new `IncomeTrendCommand` is returned back to `LogicManager`.

6. The `LogicManager` executes `IncomeTrendCommand#execute()`.

7. The model is updated with the `List` of `Data` from the newly created `TrendReport`.
// end::analyticsincome[]

// tag::analyticsbalance[]
==== View Balance Trend

The view balance trend feature allows the user to view monthly balance trend for a year.
This feature is facilitated by `AnalyticsFeatureParser`, `BalanceTrendCommandParser`, and `BalanceTrendCommand`.
The argument supported by this feature is:

- `Year` (optional)

===== Implementation

When the user input the `balance` command in the Analytics tab, the following chain of operations occurs:

1. The `IchiFundParser` will delegate the parsing of the command to `AnalyticsFeatureParser` if the current active tab is Analytics.

2. The `AnalyticsFeatureParser` will delegate the parsing of the arguments to `BalanceTrendCommandParser`.

3. `BalanceTrendCommandParser#parse()` will take in a `String` input consisting of the arguments.

4. This arguments will be tokenized and the respective models for each argument are created.

5. If the parsing of all arguments are successful, a new `BalanceTrendCommand` is returned back to `LogicManager`.

6. The `LogicManager` executes `BalanceTrendCommand#execute()`.

7. The model is updated with the `List` of `Data` from the newly created `TrendReport`.
// end::analyticsbalance[]

=== [Demo] Use this as template for your section
==== Proposed Implementation
===== Test

The undo/redo mechanism is facilitated by `VersionedAddressBook`.
It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedAddressBook#commit()` -- Saves the current address book state in its history.
* `VersionedAddressBook#undo()` -- Restores the previous address book state from its history.
* `VersionedAddressBook#redo()` -- Restores a previously undone address book state from its history.

These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

image::UndoRedoState0.png[]

Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

image::UndoRedoState1.png[]

Step 3. The user executes `add n/David ...` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

image::UndoRedoState2.png[]

[NOTE]
If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

image::UndoRedoState3.png[]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial address book state, then there are no previous address book states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoSequenceDiagram.png[]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

The `redo` command does the opposite -- it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

[NOTE]
If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone address book states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

image::UndoRedoState4.png[]

Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.

image::UndoRedoState5.png[]

The following activity diagram summarizes what happens when a user executes a new command:

image::CommitActivityDiagram.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of address book states.
** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
// end::undoredo[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* a financially conscious CS undergraduate
** has a need to track expenditure and income items
** has a need to limit expenditure to a budget
** has a need to quickly analyse how to reduce expenditure
** has a need to track net worth
** has a need to track loans and money owed
** prefers desktop apps over other types
** can type fast
** prefers typing over mouse input
** is reasonably comfortable using CLI apps

*Value proposition*:

* manage financial transactions faster than a typical mouse/GUI driven app
* analyse past expenditure, income and balance trends

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user who is keeping track of transactions |record transactions |

|`* * *` |user who is keeping track of transactions |edit transactions |update any errors made when adding transactions

|`* * *` |user who is keeping track of transactions |view transactions |

|`* * *` |user who is keeping track of transactions |organize transactions by category |

|`* * *` |user who is keeping track of transactions |delete transactions |delete wrongly added or refunded transactions

|`* * *` |user who is keeping track of transaction recurrence |create transaction repeaters |insert new transaction repeater.

|`* * *` |user who is keeping track of transaction recurrence |edit transaction repeaters |update any changes or errors in existing transaction repeaters.

|`* * *` |user who is keeping track of transaction recurrence |delete transaction repeaters |delete no longer relevant transaction repeaters.

|`* * *` |user who is keeping track of transaction recurrence |filter transaction repeaters |quickly find transaction repeaters relevant to a search query.

|`* * *` |user who is keeping track of net worth |set my current wealth |keep track of how much money I have

|`* * *` |user who is keeping track of budget |set my monthly expenditure budget |keep track of how much I can spend for the month

|`* * *` |user who is keeping track of budget |exclude transaction from budget |

|`* * *` |user who is keeping track of budget |include transaction to budget |

|`* * *` |user who is keeping track of budget |see an overview of my budget |

|`* * *` |user who is trying to reduce expenditure |view my monthly expenditure trends |keep track of how much I spend per month

|`* * *` |user who is trying to reduce expenditure |view my expenditure breakdown by category |keep track of how much I spend by category

|`* *` |user who is trying to reduce expenditure |view my expenditure category ranking chart |keep track of my top expenditure categories

|`* *` |user who is trying to reduce expenditure |view my expenditure ranking chart by month |keep track of my top expenditure months

|`* *` |user who is trying to reduce expenditure |view my expenditure ranking chart |keep track of my top expenditures

|`* *` |user who is keeping track of net worth |view my monthly income trends |keep track of how much I earn per month

|`* *` |user who is keeping track of net worth |view my monthly balance trends |keep track of how much I save per month

|`* *` |long-term user who is keeping track of transactions |find transactions by keyword |conveniently search for transactions to edit or review

|`* * *`|user who wants to keep track of money owed |view all loans |see all money i am owed or currently owe others

|`* * *`|user who wants to keep track of money owed |view all positive loans |see all money people owe me

|`* * *`|user who wants to keep track of money owed |view all negative loans |see all money i owe people

|`* *`|user who wants to keep track of money owed |select loans by names/keywords |see all loans by a particular person

|`* * *`|user who wants to keep track of money owed |new loan in the list |add a new loan to keep track of

|`* * *`|user who wants to keep track of money owed |mark loan as loan paid |remove one of the loans

|`* *`|user who wants to keep track of money owed |paid/add by part |some amont of loan is paid off

|`*`|user who wants to keep track of money owed | reminders to pay loans with dates |I can see updates and reminders for urgent loans

|=======================================================================

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `IchiFund` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Set current wealth

*MSS*

1.  User requests to set current wealth.
2.  System sets current wealth.
3.  System reflects newly set current wealth.
+
Use case ends.

[discrete]
=== Use case: Add transaction item

*MSS*

1.  User enters information about transaction.
2.  System creates transaction item.
3.  System shows newly updated list of transaction items.
+
Use case ends.

[discrete]
=== Use case: Edit transaction item

*MSS*

1.  User +++<u>finds transaction item</u>+++.
2.  User specifies transaction to be edited and information to edit.
3.  System updates the transaction item.
4.  System shows newly updated list of transaction items.
+
Use case ends.

[discrete]
=== Use case: Delete transaction item

*MSS*

1.  User +++<u>finds transaction item</u>+++.
2.  User specifies transaction to be deleted.
3.  System removes the transaction item.
4.  System shows newly updated list of transaction items.
+
Use case ends.

[discrete]
=== Use case: Change filter of transaction list

*MSS*

1.  User specifies month, year, category and/or type of the transaction
2.  System updates filter of list of transaction items.
+
Use case ends.

[discrete]
=== Use case: Find transaction item

*MSS*

1.  User specifies keywords of the transactions to be found.
2.  System updates list of transaction items to show applicable transactions.
+
Use case ends.

[discrete]
=== Use case: Archive transaction item

*MSS*

1.  User specifies index of transaction to be archived
2.  System moves transaction to archive.
3.  System shows newly updated list of transaction items.
+
Use case ends.

[discrete]
=== Use case: Create transaction repeater

*MSS*

1. User requests to create a transaction repeater with specified arguments.
2. System creates the transaction repeater.
+
Use case ends

[discrete]
=== Use case: Edit transaction repeater

*MSS*

1. User requests to edit a transaction repeated with specified arguments.
2. System updates the transaction repeater.
+
Use case ends

[discrete]
=== Use case: Delete transaction repeaters including all produced transactions

*MSS*

1. User requests to delete a transaction repeater together with all its produced transactions.
2. System removes existing transactions produced from transaction repeater.
3. System removes transaction repeater.
+
Use case ends

[discrete]
=== Use case: Filter transaction repeaters

*MSS*

1. User requests to find transaction repeaters by specified fields.
2. System filters existing transaction repeaters against specified fields.
3. System shows filtered transaction repeaters.
+
Use case ends

[discrete]
=== Use case: Set monthly expenditure budget

*MSS*

1.  User requests to set the monthly expenditure budget.
2.  System set the monthly expenditure budget.
+
Use case ends.

[discrete]
=== Use case: Add loan

*MSS*

1. User requests to add a new loan with name, amount and date by.
2. System parses request to retrive details.
3. System adds new loan to list.
4. System updates list and displays what was added.
+
Use case ends

[discrete]
=== Use case: View loans with search
*MSS*

1. User requests to search for all loans, with search keywords.
2. System parses and decides the request search constrains.
3. System displays seelected search results.
+
Use case ends

[discrete]
=== Use case: Mark loans as part done

*MSS*

1. User requests to mark a lone as paid off.
2. System removes existing loan from the list.
3. System updates the total loan value.
4. System shows the new total loan value, with the new paid off loan.
+
Use case ends

*Extensions*

[none]
* 1a. System detect an invalid budget amount.
+
[none]
** 1a1. System shows an error message.
+
Use case ends.

[discrete]
=== Use case: View expenditure trend

*MSS*

1.  User requests to view expenditure trend over a period.
2.  System retrieves expenditure entries for each month in the indicated period.
3.  System totals up expenditure for each month in the indicated period.
4.  System shows the expenditure totals for each month in the indicated period.
+
Use case ends.

[discrete]
=== Use case: View expenditure breakdown by category

*MSS*

1.  User requests to view expenditure breakdown by category over a period.
2.  System retrieves expenditure entries for each category in the indicated period.
3.  System totals up expenditure for each category in the indicated period.
4.  System shows the expenditure totals for each category in the indicated period.
+
Use case ends.

[discrete]
=== Use case: View expenditure ranking chart

*MSS*

1.  User requests to view expenditure ranking chart over a period.
2.  System retrieves all expenditure entries in the indicated period.
3.  System sorts expenditure entries in the indicated period.
4.  System shows the sorted expenditure entries in the indicated period.
+
Use case ends.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 transactions without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
_{More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[appendix]
== Product Survey

*DBS digibank SG*

Author: DBS Bank Ltd

Pros:

* Links to bank account and PayLah!
* Shows visual summary of cashflow
* Automatically categorizes items

Cons:

* Does not use CLI
* Does not allow for customisation of transactions beyond categories
* Does not have a budgeting feature

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
