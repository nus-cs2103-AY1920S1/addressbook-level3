= DukeAcademy - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://ay1920s1-cs2103t-f14-1.github.io/main/

By: `Team AY1920S1-CS2103T-F14-1`      Since: `Sept 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/difficulty/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/difficulty/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.

The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of six components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: Includes 3 types of executors: the Command Executor, the Program Submission Executor, and the Question Builder Executor,.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.
* <<Design-Observable, *`Observable`*>>:
* <<Design-TextExecutor, *`TextExecutor`*>>: Compile the user program and run it against test cases. Output result.

Each of the six components:

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `QuestionLogic` component (see the class diagram given below) defines it's API in the `QuestionLogic.java` interface and exposes its functionality using the `QuestionLogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `view 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassUml.png[]

*API* : link:{repoURL}/src/main/java/seedu/difficulty/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/difficulty/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/difficulty/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/difficulty/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Duke Academy data.
* exposes an unmodifiable `ObservableList<Question>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Duke Academy`, which `Question` can reference. This would allow `Duke Academy` to only require one `Tag` object per unique `Tag`, instead of each `Question` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

//tag::storage[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* :

For Questions, link:{repoURL}/src/main/java/com/dukeacademy/storage/question/QuestionBankStorage.java[`QuestionBankStorage.java`]

For Profile, link: {repoURL}/src/main/java/com/dukeacademy/storage/profile/ProfileStorage.java[`ProfileStorage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Duke Academy question bank in json format and read it back.
* can save the user information in json format and read it back.

//end::storage[]

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `com.dukeacademy.commons` package.

**Core**:

**Exceptions**:

`DataConversionException`: occurs when loading files with incorrect data format.

`IllegalValueException`: occurs when user inputs a invalid command.

**Util**:

`FileUtil`: for loading and saving of files.
`JsonUtil`: for serializing and deserializing json files.

...TBA

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::submit[]
=== [Proposed] Submit feature

The submit mechanism is facilitated by `UserInterface`.

The Sequence Diagram given below is an example of a scenario in which the submit command is executed when the user enters "submit" into the `CommandBox` terminal.

image::submitSequenceDiagram.png[]

Step 1. The user enters "submit" into the `CommandBox`.

Step 2. The will call the `executeCommand()` method of the `CommandLogicManager` which will then call the `parseCommandText()` method of the `CommandParser`.

Step 3. The CommandParser then calls the constructor of the Command class to create a new Command object, which is then returned to the `CommandLogicManager`.

Step 4. CommandLogicManager then calls the `execute()` method of the newly created Command object.
The UI will then retrieve the user-written code from within the `Editor` as a String to be passed onto the `ProgramSubmissionLogicManager` to be compiled as a .class file for execution.

Step 5: After running the .class file, the output is then displayed to the user through the UI.
// end::submit[]

=== Evaluation of user program submissions
The evaluation of the user's programs is facilitated by the `solutions` package.

==== Entry point

It contains the class `TestExecutor`
which contains a single method `runTestCases(testCases, program)`. This method is used to run a user's program against
a series of test cases.

The method utilizes the classes `TestCase` and `UserProgram` to model the data needed for evaluation.

====
*TestCase* - stores an input and an expected value

image:TestCaseClassDiagram.png[width=240]

*UserProgram* - stores the main class name and the program's source code a String (note that the specified class name
must match the source code for it to be successfully evaluated)

image:UserProgramClassDiagram.png[width=240]

====

The result of the evaluation is returned as a `TestResult` object.

====
*TestResult* - encapsulates all the possible outcomes of evaluating the user's program. It is composed of other model
classes -- `TestCaseResult`, `CompileError`.

image::TestResultDiagram.png[align=center]

====

==== Implementation overview

The evaluation of a user's program is done in 3 main steps, each handled by a specialized interface. The 3 steps include:

====
1. Create a Java file inside a temporary directory in the user's file system and writing the user's program to it.

2. Compile that Java file into an executable Java Class file. Catch and store compile errors if any.

3. Execute the main Class file and provide the inputs of the specified test cases. Collect and store any output from the program.

4. Encapsulate the output, errors and results in a model class
====

This is done by `TestExecutor` with the help of three interfaces that are made available through dependency injection --
`CompilerEnvironment`, `Compiler`, `ProgramExecutor`.

Each interface has its specialized role in the evaluation process.
`TestExecutor` acts as an orchestrator to tie all their functionalities together.

====
*CompilerEnvironment* - in charge of creating a temporary folder in the user's file system to create and write Java files.
This temporary folder is deleted after `closed()`. Utilizes the model class `JavaFile`.

image::CompilerEnvironment.png[align=center]

*Compiler* - in charge of compiling the Java files into Class files at a given file path. Utilizes the model class `ClassFile`.

image::Compiler.png[align=center]

*ProgramExecutor* - in charge of executing the compiled Class files. Utilizes the model class `ProgramOutput`.

image::ProgramExecutor.png[align=center]

*Models:*

* *JavaFile* - contains the canonical name and class path of a Java file with various convenience methods. Note that the file must actually exist or
an `FileNotFoundException` is thrown during instantiation.
* *ClassFile* - contains the canonical name and class path of a Java file with various convenience methods. Note that the file must actually exist or
an `FileNotFoundException` is thrown during instantiation.
* *ProgramInput* - contains the String input to be fed into the user's program.
* *ProgramOutput* - contains the String output produced by the user's program. It also contains convenience methods for producing different outputs.
====

====
*Sequence diagram:*

1. `TestExecutor` calls `clearEnvironment()` of `CompilerEnvironment` to remove any redundant files from previous program
evaluations.

2. `TestExecutor` calls `createJavaFile()` of `CompilerEnvironment` to create the Java file with the class name and source code specified
in the `UserProgram` argument.

3. `TestExecutor` calls `compileJavaFile()` of `Compiler` to compile the newly created Java file.

4. For each test case passed in the argument, `TestExecutor` calls `executeProgram` of `StandardProgramExecutor` with the input from the
test case.

5. `TestExecutor` maps each `ProgramOutput` received into a `TestCaseResult` model instance.

6. `TestExecutor` packs all the data collected from the execution of the test cases into a single `TestResult` instance.

image::TestExecutorSequenceDiagram.png[align:center]
====

==== Implementation details
The implementations of `CompilerEnvironment`, `Compiler` and `ProgramExecutor` used in the application are as follows:

* *StandardCompilerEnvironment* - this implementation utilizes Java11's native Files library to handle creation, deletion and writing of files.

    - Creates a temporary folder when instantiated at the file path injected through its constructor.

    - All files are created in this temporary folder.

    - The temporary folder is deleted in the `close()` method.

    - When tasked to create a new file, it first creates an empty file in the temporary folder before writing the contents of the user's program to the file

* *StandardCompiler* - this implementation utilizes Java11's native JavaCompiler library to programmatically compile Java files.

    - Compile errors recorded by the `DiagnosticsListener` class from the compilation task is parsed and rethrown as `CompilerException` and `CompileContentException`.
    - `CompilerException` represents compile errors caused by the JavaCompiler library while `CompileContentException` represents errors caused by the user's program.

* *StandardProgramExecutor* - this implementation utilizes Java11's native Runtime class to execute programs programatically.

    - To execute a program, `exec(String command)` of the Runtime instance is called.
    - A command to compile the specified `ClassFile` is generated using its class path and canonical name attributes.
    - The method returns a `Process` instance that executes the program on a separate thread.
    - `StandardProgramExecutor` accesses the input stream of the process and feeds the program the necessary inputs.
    - `StandardProgramExecutor` access the output and error stream of the process and collects any produced output or errors.
    - The process is destroyed and the collected output and errors and packaged as a `ProgramOutput` instance.

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

=== Home Page

The home page of Duke Academy is the main page that the user sees upon app initialization. Not only does it provide an
introduction and greeting to the user, it also functions as a personal dashboard.

As a personal dashboard, it presents the user with essential information about his personal progress and learning
journey.

Here are three main pieces of information presented to the user:
1. Number of questions completed`
2. Questions that user is still working on
3. Questions that user chose to bookmark for personal reference

To obtain these three pieces of information, we first obtain the `ObservableList` that represents all questions in the
storage. We can obtain this `ObservableList`, from `QuestionLogic`, through a method named `getFilteredQuestionsList()`.

The controller class for Home Page, `HomePage.java` has a constructor that takes in this `ObservableList`. Through
helper methods within the controller class, we can do some processing to the `ObservableList` and easily generate the
three pieces of data.

These pieces of information will then be displayed on the Home Page through standard JavaFX controls.

=== Code Result Panel

The code result panel is a panel below the editor that shows the evaluation of the user's program against the specified
test cases in the question.

It takes in a `List` of `TestCaseResults` which contains useful information about how the user's program fared against
the various test cases.

These information are then displayed on the Code Result Panel through standard JavaFX controls.

//tag::problem_description[]
== Problem Description Panel
//end::problem_description[]

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

//tag::appendix[]
[appendix]
== Product Scope

*Target user profile*:

* has a need to practice a lot of algorithm / data structure problems with the following conditions satisfied:
+
[none]
** instant assessment of answers submitted
** practices under timed conditions
** automatic progress checker
** personal tutor to recommend problems with suitable difficulties and topics
** fun in learning with achievement badges to unlock
** no WiFi needed,

* or has a need to distribute problem sets:
+
[none]
** can set the coding problems easily
** share problems via link
** view-only answers protected by passwords

* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*:
[none]
* everyone can learn data structures - anytime, anywhere
* make coding threshold-less
* manage contacts faster than a typical mouse/GUI driven app


[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |student from university courses|search problems by partially matching keywords|identify the problem I am required to do asap

|`* * *` |developer|introduce new problems to the software easily |the repository of code challenges can be updated without much hassle

|`* * *` |coding student|look back on the coding challenges I have completed|revise the concepts used in those problems

|`* * *` |job seeker|view past interview problems by a company|increase my chances of getting hired

|`* * *` |user|see the difficulties of each problem|choose to do problems that are more aligned to my standard

|`* *` |developer|receive detailed auto-generated error reports if any bug occurs|correct them

|`* *` |forgetful user|set reminders|be reminded of the problems that I need to solve before a deadline

|`* *` |unorganized coder|view my progress on different categories|know which area I am weak in

|`* *` |programming course student |attempt problems under timed condition|I feel more prepared in timed assessments such as labs, practical exam and final exam.

|`* *` |tutor|choose to reveal the answers to the solutions through a password|

|`* *` |coder|identify the concepts required to solve a problem before attempting them |move on to another quickly

|`* *` |a coding student|attempt the same problem in different coding languages|test my proficiency at those languages

|`* *` |coding amateur|look at hints/tutorials for the problem|learn something new while attempting a coding challenge

|`* *` |coding student|share coding challenges with my friends easily|discuss possible solutions with them
|`* *` |achievement hunter|view the badges that I have earned (and those that I have not)|feel a sense of accomplishment
|`* *` |conscientious coding student|easily identify problems that I have given up on previously|tackle them again
|`* *` |professor teaching this course|assign a unique hash code for each problem I input|students can look for the problems quickly

|`* *` |picky coder|select different themes for the software|the user interface looks more appealing to me

|`* *` |programming language polyglot|specifically choose problems designed in a specific language|practice that language in focus

|`* *` |coding student|view similar/related problems to the one I have just completed |further deepen my understanding of the concepts used

|`* *` |easily distracted coder|switch off all external distractions|focus better on the problem I am working on

|`* *` |busy coder|save my progress on a problem|come back to it and continue at a later time

|`* *` |competitive programming enthusiast|set my own questions and pose them to my fellow enthusiast friends to solve|

|`* *` | student |see statistics about my attempts/success rates to track my learning progress|

|`*` |tutor|print a pdf version of the coding problem |give them as practices to my students

|`*` |competitive coder|see my areas for improvement after completing a coding challenge|become a better competitive coder

|`*` |international student|view translation of the problem statement|aids my understanding of the problem
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `Duke Academy` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: UC01 Set questions
*MSS*

1. User requests to input problem sets.
2. Duke Academy requires a file path.
3. User select file path.
4. Duke Academy imports the problem sets and prompts success message.
+
Use case ends.

*Extensions*
[none]
* 4a. The input format is incorrect.
+
Duke Academy reports wrong format error. Duke Academy resumes at step 3.

=== Use case: UC02 View Questions
*MSS*

1. User finds a question by question ID, title or category.
2. Duke Academy shows a list of problems that matches the keyword.
3. User views the question identified by ID.
4. Duke Academy displays the problem statement of the question.
+
Use case ends.

*Extensions*
[none]
* 1a. User inputs wrong keywords.
+
Duke Academy reports error and prompts link to help page.
+
Use case resumes at step 1.

=== Use case: UC03 Attempt Questions
*MSS*

1. User chooses a problem to attempt.
2. Duke Academy shows up the problem statement and an editor.
3. User inputs the code in editor.
4. User submit the answer.
5. Duke Academy compiles the problem and display whether it has passed the test cases.
+
Use case ends.

*Extensions*

[none]
* 2a. User requests to reset the previous input in the editor for this question.
+
[none]
** 2a1. Duke Academy clears the cached code.
+
** Use case resumes from step 3.

* 2b. User requests to set a timer.
+
[none]
** 2b1. Duke Academy requests for a time duration.
** 2b2. User inputs a time duration.
** 2b3. Duke Academy displays a timer.
** 2b4. User starts the timer.
+
Use case resumes from step 4.

* 2c. User requests to quit the program.
+
[none]
** 2c1. Duke Academy requests to save the draft.
** 2c2. User confirms or denies.
** 2c3. Duke Academy follows user's preference to save or discard the draft.
** 2d4. Duke Academy exists.
+
Use case ends.

* *a. At any time, user chooses to attempt an question imported from external resources.
+
[none]
** *a1. load the questions from file.
+
*a2. Duke Academy stores the problem in local machine.
+
*a3. User search for the problem imported.
+
*a4. Duke Academy displays the question.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 problem sets without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
. Time taken to assess the submitted programmes should not exceed 3 minutes.
. <<encryption,Data not intended for disclosure>> should be encrypted with minimum needs so that it's protected from direct access.
. Should not take more than 5 seconds to load the initial screen.
. If interrupted, the program should provide an auto-saved version and prompt for restore when the app opens next time.



[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[encryption]] Data not intended for disclosure::
[none]
* User information that is not meant to be shared with others.
* Confidential program sets for technical interviews.
* To prevent plagiarism, input code files intended for graded school assessment.

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_

//end::appendix[]
