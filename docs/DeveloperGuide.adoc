= Budget Buddy - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-W13-4/main

By: `CS2103T W13-4`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

`Main` has two classes called link:{repoURL}/src/main/java/budgetbuddy/Main.java[`Main`] and link:{repoURL}/src/main/java/budgetbuddy/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/budgetbuddy/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `ListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/budgetbuddy/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/budgetbuddy/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `CommandLineParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a loan).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  The `CommandResult` is used to display feedback to the user and update the current active tab based on its `CommandCategory`.
.  For certain commands (e.g. `help`, `script add`) the `CommandResult` will have a `CommandContinuation`
that will perform further actions or return a new `CommandResult` to evaluate again.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("account delete 1")` API call.

.Interactions Inside the Logic Component for the `account delete 1` Command
image::DeleteSequenceDiagram.png[]

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

[NOTE]
The lower levels of each `XYZManager` class can be viewed in their respective sections in the <<implementation,Implementation>> section.
For example, a more detailed class diagram of the `AccountsManager` can be found in <<accounts-feature,Section 3.1.1>>.

*API* : link:{repoURL}/src/main/java/budgetbuddy/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores Budget Buddy's data.
* exposes multiple unmodifiable `ObservableLists` that can be 'observed' e.g. the `PanelTab`s in UI are bound to these lists so that the UI automatically updates when the data in the lists change.
* does not depend on any of the other three components.

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/budgetbuddy/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save Budget Buddy's data in json format and read it back.

Budget Buddy saves its data in a few different json files,
namely `accounts.json`, `loans.json`, `rules.json` and `/scripts/descriptions.json`.
In addition, the user's custom scripts are saved in the `/scripts/` folder.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `budgetbuddy.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::accounts[]
=== Accounts Feature
==== Implementation

The Accounts Feature allows the users to manage their accounts.
It is managed by `AccountsManager`, with `Account` objects stored internally in a `Accounts` and `filteredAccounts`.

The class diagram below shows how the `AccountsManager` maanges its list of `Account` objects:

image::AccountClassDiagram.png[]

Each `Account` object has the following attributes:

* `name:Name` -- The name of account created.
* `description:Description` -- A description of the account to describe the use of the account.
* `transactionList:TransactionList` -- The list of transactions associated with the account.
* `isActiveBooleanProperty:BooleanProperty` -- The boolean property indicating whether an account is active or inactive.
* `balance:long` -- The balance of the account, calculated by the net sum of expenses and income.
* `balanceLongProperty:LongProperty` -- The Long property of the balance.
* `categoryset:Set<Category>` -- The set of categories involved in the account.

To facilitate the manipulation of `Account` objects, `AccountsManager` implements the following operations:

* `AccountsManager#updateFilteredAccountList(Predicate<Account> predicate)` -- Updates the predicate of `filteredAccounts`.
* `AccountsManager#getFilteredAccountList()` -- Gets the list of `filteredAccounts` after applying its `predicate`.
* `AccountsManager#resetFilteredAccountList()` -- Reset `filteredAccounts` so that all accounts present in `accounts` exist in `filteredAccounts`.
* `AccountsManager#getActiveTransactionList()` -- Gets the `activeTransactionList` of the active account.
* `AccountsManager#getAccounts()` -- Gets the list of `accounts`.
* `AccountsManager#size()` -- Gets the size of the `accounts` list.
* `AccountsManager#addAccount(Account toAdd)` -- Adds the `Account toAdd` to `accounts`.
* `AccountsManager#deleteAccount(Account toDelete)` -- Deletes the account at `Index toDelete` from `accounts`.
* `AccountsManager#editAccount(Index toEdit, Account editedAccount)` -- Edits the account at `Index Edit` to match `Account editedAccount`.
* `AccountsManager#switchActiveAccount(Index targetAccountIndex)` -- Inactivate the current active account, and activate the target account.
* `AccountsManager#unsetActiveAccount()` -- Inactivate any currently active account.
* `AccountsManager#setActiveAccount(Index toSet)` -- Activate the target account.
* `AccountsManager#getAccount()` -- Gets the target account.
* `AccountsManager#getActiveAccountIndex()` -- Gets the index of the currently active account.
* `AccountsManager#getActiveAccount()` -- Gets the currently active account.
* `AccountsManager#transactionListSwitchSource(Account account)` -- Switches the account source for the TransactionList.
* `AccountsManager#transactionListUpdateSource()` -- Updates the transactionList linked to the currentActiveAccount.
* `AccountsManager#exportReport()` -- Exports the overview report of all accounts.

When the user inputs a command, several of the above operations are carried out.
For example, `account edit` will call `AccountsManager#resetFilteredAccountList` to update the `filteredAccounts`,
so that all accounts present in `accounts` will be present in `filteredAccounts`,
then `AccountsManager#editAccount` to edit the account,
finally `AccountsManager#getFilteredAccountList()` to display the list of accounts.

After each command, the list of `accounts` is saved in `accounts.json`,
which is stored in a `data` folder in the same directory as `budgetbuddy.jar`.

Given below is an example usage scenario and how the `AccountsManager` behaves at each step.

Step 1. The user launches the application.
If this is the first time it is launched,
`accounts.json` is created and the `AccountsManager` initializes with an `accounts` containing a default account.
Otherwise, the data in `accounts.json` is loaded into `accounts`.

Step 2. The user executes `account add n/Japan trip d/expense spent in Japan` to add a new account.
This creates a new account `toAdd` with the `name` as Japan trip and `description` as expense spent in Japan.
`AccountsManager#addAccount(Account toAdd)` adds `toAdd` to `accounts`.
`filteredAccountList` will be automatically updated to match `accounts`.

Step 3. The user executes the command `account find trip` to find account contains the keyword trip specified.
`AccountsManager#updateFilteredAccountList` sets the predicate of `filteredAccounts` according to the input parameters.
Finally, `AccountsManager#getFilteredAccounts` retrieves an immutable version of `filteredAccounts` (filtered) to display to the user.
In this case, an account with the `name` as Japan trip and `description` as expense spent in Japan will be displayed.

The following sequence diagram shows how finding the accounts containing specified keyword works:

image::AccountSequenceDiagram.png[]

Most of the commands and operations behave in the same way.
The only difference will be the the action taken by the operation (e.g. finding account or adding account).

Step 4. The user executes `account delete 2` to delete the second account in the `accounts`.
Firstly, `AccountsManager#resetFilteredAccountList` will update the `filteredAccounts`,
so that all accounts present in `accounts` will be present in `filteredAccounts`,
then `AccountsManager#deleteAccount` deletes `toDelete` account from `accounts`.

Step 5. The user executes `account edit 3 n/food` to edit the `name` of the first account.
A new `editedAccount` is created, which is the same as the first third account except for its `name` which is food.
`AccountsManager#editAccount(Index toEdit, Account editedAccount` replaces the account at index `toEdit` with `editedAccount.`

The activity diagram below shows what happens when the user executes `account edit`:

image::AccountActivityDiagram.png[]

Step 6. The user executes `account report 2` to view the details of the second account.
Firstly, `AccountsManager#resetFilteredAccountList` will update the `filteredAccounts`,
so that all accounts present in `accounts` will be present in `filteredAccounts`,
then `AccountsManager#getAccount` and `Account#getAccountInfo` are used to display the details of the second account.

Step 7. The user executes `account overview` to view the report of all accounts in an html export file.
Firstly, `AccountsManager#resetFilteredAccountList` will update the `filteredAccounts`,
so that all accounts present in `accounts` will be present in `filteredAccounts`,
then `AccountsManager#exportReport` generates the overview of all accounts html file to the exports folder.

[NOTE]
For `account edit`, `account delete` and `account report`,
if the user targets an index beyond the last index,
an error message is displayed.

==== Design Considerations
===== Aspect: Interaction with ui - the list retrieved by `LogicManager`

In the mainWindow of ui, `AccountTab` is associated with a list of accounts. However, two lists of accounts are required.
One stores all the current accounts present in `accounts`, the other one stores the `filteredAccounts` with the filtered accounts after `account find` executes.

* **Alternative 1 (current choice)**: `AccountTab` is only associated with `filteredAccounts` as `filteredAccounts` stores all accounts.
After each command, `AccountsManager#resetFilteredAccountList` is called to reset the predicate to be true, so that `filteredAccounts` matches `accounts`.
** Pros: Only one list of accounts is associated with `LogicManager`.
** Cons: It is counter-intuitive as `filteredAccounts` is supposed to stored the accounts that have been selected.
* **Alternative 2**: `AccountListPanel` is associated with both `filteredAccounts` and `accounts`, and the display of the list switches when necessary.
** Pros: Easy to understand and align with the common sense.
** Cons: Hard to implement.
// end::accounts[]

// tag::loans[]
=== Loans Feature
==== Implementation

The Loans feature exists outside of the Account/Transaction mechanisms.
It adds a separate `LoansManager` alongside the main `AccountsManager`, with `Loan` objects stored internally in an `internalList`.

The following class diagram demonstrates the association between the `LoansManager` and `Loan` objects.
Miscellaneous methods (such as `LoansManager#getLoans` and `LoansManager#getLoansCount`) are omitted.

[[loan-class-diagram]]
.Class Diagram of the Loans Model
image::LoanClassDiagram.png[]

[NOTE]
The `Debtor` class, `LoansManager#debtors`, `LoansManager#setDebtors` and `LoansManager#getDebtors` can be ignored for now.
They are depicted here for the sake of completion,
but will only be used when discussing the `loan split` command in a <<Loan Splitting,later section>>.

Each `Loan` object has the following attributes:

* `person:Person` -- The person that the user lent/borrowed money to/from.
* `amount:Amount` -- The amount of money loaned.
* `direction:Direction` -- The direction of the loan (either `IN` or `OUT`).
* `status:Status` -- The status of the loan (either `PAID` or `UNPAID`).
* `date:LocalDate` -- The date of the loan.
* `description:Description` -- A description of the loan.

To facilitate the manipulation of `Loan` objects, `LoansManager` implements the following operations:

* `LoansManager#updateFilteredList(Predicate<Loan> predicate)` -- Updates the current predicate of `filteredLoans` to `predicate`.
* `LoansManager#sortLoans(Comparator<Loan> sorter)` -- Sorts `internalList` using the given `sorter`.
* `LoansManager#getFilteredLoans()` -- Gets `filteredLoans`, representing the loans in `internalList` after filtering.
* `LoansManager#addLoan(Loan toAdd)` -- Adds the `Loan toAdd` to `internalList`.
* `LoansManager#editLoan(Index toEdit, Loan editedLoan)` -- Replaces the loan at `Index toEdit` with `Loan editedLoan`.
* `LoansManager#updateStatus(Index toUpdate, Loan updatedLoan)` -- Replace the loan at `Index toUpdate` with `Loan updatedLoan`.
* `LoansManager#deleteLoan(Index toDelete)` -- Deletes the loan at `Index toDelete` from `internalList`.

Each user-given command will call at least one of the above operations.
For example, `loan delete` will call `LoansManager#deleteLoan` to delete the targeted loan(s),
then `LoansManager#getFilteredLoans` to display the remaining loans.

After each command, the state of `internalList` is saved in the file `loans.json`.
`loans.json` is stored on the local hard disk in a `data` folder,
which is in the same directory as `budgetbuddy.jar`.

Given below is an example usage scenario and how the `LoansManager` behaves at each step.

Step 1.
The user launches the application.
If `loans.json` exists on the hard disk, its data is loaded into `internalList`.
Otherwise, `loans.json` is created and the `LoansManager` initializes with an `internalList` containing a few sample loans.

Step 2.
The user executes the command `loan out p/John x/4.20 d/Paid for his lunch` to add a new loan.
This creates a new loan `toAdd` of `amount` 4.20 `out` to the `person` John, with the description `Paid for his lunch`.
Since the user did not provide a date, the current system date is used for the `date` of `toAdd`.
`LoansManager#addLoan(Loan toAdd)` is called and
(after verifying that `toAdd` does not already exist in `internalList`)
`toAdd` is added to `internalList`.

The following sequence diagram illustrates the process of adding a loan:

.Sequence Diagram for Adding a Loan
image::LoanSequenceDiagram.png[]

In general, the rest of the operations work using a similar sequence of steps.
Some commands might create a new `Loan` object (as shown above) while others might just use the `Index` of a loan (e.g. `loan delete`).

Step 3.
The user executes the command `loan list out p/John w/1/11/2019 s/x`
to see all loans `out` to `John` dated `1/11/2019`, sorted by amount.
First, `LoansManager#sortLoans` is called to sort the loans in `internalList` by their amounts in ascending order.
`LoansManager#updateFilteredList` is then called to set the predicate of `filteredLoans`;
the new predicate filters the list to loans `out` to the person `John` on `1/11/2019`.
Finally, `LoansManager#getFilteredLoans` is called to display the (sorted and filtered) list to the user.

Step 4.
The user executes the command `loan paid 1` to update the status of the first loan in the list to `PAID`.
This creates a new `updatedLoan` identical to the first loan in `internalList`, except that `updatedLoan` has the status `PAID`.
`LoansManager#updateStatus(Index toUpdate, Loan updatedLoan)` is called
(where `toUpdate` is the index of the first loan in `internalList`)
and the loan at index `toUpdate` is replaced with `updatedLoan`.

[NOTE]
The command `loan unpaid` works identically to `loan paid`, except that the `status` of `updatedLoan` is set to `UNPAID`.

Step 5.
The user executes the command `loan edit 1 x/500` to edit the `amount` of the first loan in the list to `500`.
`LoansManager#editLoan(Index toEdit, Loan editedLoan)` is called
and the loan at index `toEdit` is replaced with an `editedLoan` that has an `amount` of `500`.
While this operation appears identical to `LoansManager#updateStatus`,
`LoansManager#editLoan` implements an extra check to ensure that `editedLoan` does not already exist in `internalList`.

[NOTE]
`LoansManager#updateStatus` does not implement the check for a duplicate loan
as the `status` of a `Loan` is not considered when comparing two loans for equality.
`internalList` is already guaranteed to have no identical loans due to the checks in
`LoansManager#addLoan` and `LoansManager#editLoan`.

Step 6.
The user executes the command `loan delete 1` to delete the first loan in the list.
`LoansManager#deleteLoan(Index toDelete)` is called
(where `toDelete` is the index of the first loan in `internalList`)
and the loan at index `toDelete` is removed from `internalList`.

[NOTE]
For the commands `loan paid`, `loan unpaid` and `loan delete`,
if the user targets a loan outside of the list (e.g. index greater than list size)
an error message will be displayed.

===== Multi-Loan Targeting

The user can target and act on multiple loans with a single command.
For example, `loan paid 1 3 4` can be used to mark the first, third and fourth loans in `internalList` as `PAID`.
Alternatively or additionally, `loan paid p/John p/Mary` can also be used
to mark all the loans of the persons John and Mary in `internalList`.
The `LoansManager` handles this by executing the appropriate operation repeatedly.
In the case of `loan paid 1 3 4`, `LoansManager#editLoan` is called once for each of the three loans.

To account for the fact that the list size might change after each operation,
the size of the list before and after each operation is compared.
If it has changed, the targeted indices are adjusted accordingly.

If any of the target loan indices cannot be found by the `LoansManager` in `internalList`,
they are added to a `missingLoanIndices` list.
Similarly, target persons that cannot be found are added to a `missingPersons` list.
Both lists are displayed to the user after other target loans that are in `internalList` have been acted upon,
notifying the user that the target `indices`/`persons` could not be found.

Multi-loan targeting is implemented for the commands `loan paid`, `loan unpaid` and `loan delete`.

===== Loan Splitting

Loan splitting exists as a command that the user can execute.
Its purpose is to split a large, initially unbalanced group payment equally among the group's members.
The following example scenario should clarify the purpose of the command:

====
John, Mary and Peter go out for dinner.
The meal costs $100, so Peter pays $90 and Mary covers the remaining $10.
However, the three want to split the bill equally among themselves.

John executes the command `loan split p/John p/Mary p/Peter x/0 x/10 x/90`.
Budget Buddy then outputs a list of the necessary payments between the three.
From this list, John can now see that he owes Peter *$33.33* and that Mary owes Peter *$23.33*.
====

To display the results of the calculations, `LoansManager` holds a list of `debtors` containing `Debtor` objects.
For your convenience, the <<loan-class-diagram,class diagram of the Loans model>> is reproduced here:

.Reproduction of Class Diagram of the Loans Model
image::LoanClassDiagram.png[]

Each `Debtor` object has the following attributes:

* `debtor:Person` -- The person who owes money to one or more creditors.
* `creditors:HashMap<Person, Amount>` -- A list of persons that the `debtor` owes money to, mapped to the amount of money owed.
Each entry in the `HashMap` represents a creditor, with their name as the `Person` key and the amount owed as the corresponding `Amount` value.

`LoansManager` also implements the `getDebtors` and `setDebtors` operations to manipulate the `debtors` list.
This list is used to hold and display the `Debtor` objects created for the latest execution of `loan split`
and is stored between sessions in `loans.json`.

Given below is an example scenario to demonstrate how the final list is calculated.
The algorithm as a whole can be summarized in the activity diagram below,
which might prove helpful for following the steps in the example scenario:

.Activity Diagram for Loan Split Algorithm
image::LoanSplitActivityDiagram.png[]

Step 1.
The user executes the command `loan split p/Kenneth p/Duke p/Adam p/Zed x/0 x/20 x/80 x/50 max/10 me/Kenneth d/Dinner`.
In this scenario, out of the total bill of *$150*,
`Kenneth` has paid *$0*,
`Duke` has paid *$20*,
`Adam` has paid *$80*
and `Zed` has paid *$50*.
Furthermore, `max/10` specifies that `Kenneth` should only pay/owe up to *$10* overall.
Finally, `me/Kenneth` marks `Kenneth` as the user;
all debts involving `Kenneth` should be added to the normal loan list with the description `Dinner`.

Step 2.
`LoanSplitCommandParser` parses the persons, amounts, and max shares into `List<Person>`, `List<Amount>` and `List<Long>` respectively.
`me/Kenneth` and `d/Dinner` are parsed into `Optional<Person>` and `Optional<Description>`.
A new `LoanSplitCommand` is instantiated with the lists and optional objects.

Step 3.
`LoanSplitCommand` replaces `Kenneth` in `List<Person>` with a `Person` with the `Name` `You`.
Using the static methods of a `LoanSplitCalculator` class, it then begins executing the following algorithm:

. The `defaultSharePerPerson` is calculated.
In this scenario, *$150* should be split among the 4 persons.
However, as `Kenneth` has a max share of *$10*, the other 3 persons must divide *$140* among themselves,
resulting in a `defaultSharePerPerson` of *$46.66*.

. Each person in `List<Person>` is given a `balance`,
calculated using the amount they paid initially (from `List<Amount>`)
minus either the `defaultSharePerPerson` or their max share if present.

. A list of all possible sub-groups (combinations) of persons is generated.
In this scenario, the number of sub-groups for the 4 persons would be *16*.

. For each sub-group of persons, if the sum of their balances is *zero*, then the following steps are performed:

.. Take the persons with the smallest and biggest balances: the `debtor` and `creditor` respectively.

.. Transfer money between the two such that one or both of their balances reaches zero.
The person(s) with a balance of zero are then removed from the group,
and a record of the `debtor`, `creditor` and `amountTransferred` is stored in a `List<DebtorCreditorAmount>`.

.. Repeat until the sub-group contains less than two persons.

. After every sub-group has been processed, `List<DebtorCreditorAmount>` is used to create the final `List<Debtor>` stored in `LoansManager`.

Step 4.
All debts involving the person `You` in `List<Person>`
are used to create loans with the description `Dinner`.
These loans are added to `internalList` in `LoansManager` using `LoansManager#addLoan`.

Step 5. The list of `debtors` in `LoansManager` is displayed to the user.
In this scenario, the display will show that
`Duke` owes `Adam` *$26.66*
and `You` (`Kenneth`, the user) owe `Zed` and `Adam` *$3.32* and *$6.68* respectively.

==== Design Considerations
===== Aspect: Structure of the loan - person interaction

* **Alternative 1 (current choice)**: `LoansManager` stores `internalList`; each `Loan` references a `Person`
** Pros: Easy to implement and understand.
** Cons: Takes a longer time to get all the loans belonging to a person.
* **Alternative 2**: `LoansManager` stores `persons` list; each `Person` stores `LoanList`; each `Loan` references `Person`
** Pros: Easy to retrieve the person of each loan and retrieve all the loans belonging to a person.
** Cons: Circular dependency and high coupling, potentially leading to lower testability and a higher bug count.
// end::loans[]

// tag::ruleMgmt[]
=== Rule Management Feature

The Rules feature exists as an integration onto the Transaction system. It makes use
of syntax processing, together with scripts to provide an automation solution to
repetitive tasks when adding transactions.

Rules are defined with a pair of predicate and action, where an action is performed
given that the predicate returns true. This predicate-action split allows us to decouple
testing from performing, which helps to increase reusability of individual predicates
and actions.

==== Implementation

Basic attributes and operators are exposed to provide users a way of writing simple
tests on transactions without having to manually check and make changes. Storing rules
works similarly to LoansManager, where individual rules are stored in a
`RuleManager` which manages all CRUD operations.

All rules are stored in a JSON file when added, formatted to be retrieved and parsed by the
application when relaunched.

The following class diagram illustrates the structure of the `*Rule*` Model component.

.Structure of the Rule Model Component
image::RuleModelClassDiagram.png[]

NOTE: The rest of the `*Script*` and `*Model*` components have been omitted to give focus on the `Rule` model component.

As mentioned above, rules are defined as a pair of predicate and action, which as seen in the above diagram, is divided into
the two abstract classes `*RulePredicate*` and `*RuleAction*`. These two classes are abstract due to two implementation
types, either script or expression. Their concrete classes are `*PredicateExpression*` and `*ActionExpression*`
for expressions and `*PredicateScript*` and `*ActionScript*` for scripts respectively.
// end::ruleMgmt[]

For predicate expressions, they are formed using binary comparison operations, which means that each expression contains
an `*Operator*` which takes in two arguments, an `*Attribute*` to represent an attribute of a `*Transaction*`, as well as
a `*Value*` to represent a given value to test against the attribute.

****
Here is an example of a part of what a user may type as a predicate expression: +
`p/outamt < 10`

This is split into the *Attribute:* `outamt` , the *Operator:* `<` , as well as the *Value:* `10` .
****

Action expressions are unary operations, which means that each expression is formed with an `*Operator*` as well, but takes
only a single argument, a `*Value*` to represent a given value to carry out the operation with.

****
Again, here is an example of a part of what a user may type as an action expression: +
`a/set_cat Cheap`

This is split into the *Operator:* `set_cat` , as well as the *Value:* `Cheap` .
****

Predicate and actions implemented as scripts on the other hand are defined with a single `*ScriptName*`, which refers to the
name of the script itself.

****
Predicate and action scripts are defined the same way. An example of both: +
`p/CheckIsTransport a/SetTransportFare`

In this case, both `CheckIsTransport` and `SetTransportFare` are `*ScriptNames*` .
****

Each and every `*Rule*` is stored within the `*RuleManager*`, which serves as an interface to manipulating the list of rules.
For example, `*RuleManager#addRule*` is used to add new rules to the list, whereas `*RuleManager#swapRules*` is used to
swap the order of two rules in the list. The `*RuleManager*` supports basic *CRUD* operations, as well as other convenience
methods such as the `*RuleManager#swapRules*` as mentioned.

==== Design Considerations
===== Aspect: Structure of expressions for rule data management
* **Alternative 1 (current choice)**: The two expression classes `*PredicateExpression*` and `*ActionExpression*`
are split into their individual components, the operators and the arguments.
** Pros: More control over the expression format, and increase reusability of individual components.
** Cons: More classes required to implement, greater overhead.
* **Alternative 2**: Expressions are just entirely stored as strings within the two classes.
** Pros: Easy to implement, ease of storage.
** Cons: Parsing has to be done even after the rule is added. This means we need to parse the expression more than once,
not only to check the validity, but again to process the rule before execution.

===== Aspect: Structure of scripts for rule data management
* **Alternative 1 (current choice)**: The two script classes `*PredicateScript*` and `*ActionScript*` contain only a
`*ScriptName*`, which is the name of the script they are referencing.
** Pros: No need to reference an entire script, and therefore much easier to validate. Storing names will also be much simpler.
** Cons: Requires checking against the `*ScriptLibrary*` to retrieve a `*Script*` when processing rules.
* **Alternative 2**: The classes will each store an entire `*Script*` within them.
** Pros: Referencing the script code when processing rules will not require access to the `*ScriptLibrary*`, and can be
taken directly from the `*PredicateScript*` or `*ActionScript*` directly.
** Cons: Creating unnecessary entire references to a script that already exists in the `*ScriptLibrary*`, and makes storage
much more complicated, as the entire script will be contained within the class.

// tag::ruleExec[]
=== Rule Execution Feature

The structure of rules were separated from the logic of rule execution to maintain the separation of concerns between the
`*Model*` and `*Logic*` components.

Rule execution is hooked into the evaluation of adding or editing a `*Transaction*`. This means that for every new transaction,
all rules within the Rule Engine will be executed on that transaction. The same can be said for modifying a transaction.

The implementation of the Rule execution is elaborated on below.

==== Implementation

The `*RuleEngine*` is a static class used for interfacing with all the rule processings functionality.

Two executable classes are used in the execution of a rule, `*Testable*` and `*Performable*`.
A `*Testable*` represents the executable form of a `*RulePredicate*`, which may be either an expression or a script.
Correspondingly, a `*Performable*` represents the executable form of a `*RuleAction*`, which may also be either an
expression or a script.

Before executing the existing rules, the index of the transaction and the account that the transaction belongs to are
supplied to the `*RuleEngine*` through the `*RuleEngine#executeRules*` method. This allows for the retrieval of the transaction
when a rule is executed against it.

When a rule is executed, this is firstly represented as the execution of the `*Testable#test*` method on the given transaction.
If the test passes, the predicate is true, and therefore the action is performed. This is represented as the execution of
the `*Performable#perform*` method on the given transaction.

The following sequence diagram shows the interaction between the `*RuleEngine*` and the different objects involved in the
execution of the rules on a transaction:

.Sequence diagram representing Rule Execution after adding a new Transaction
image::RuleExecutionSequenceDiagram.png[]

Shown above is a sequence diagram which takes place during the execution of the `*TransactionAddCommand*`,
after the new transaction has already been added. The `*RuleEngine*` takes over, and retrieves the relevant handlers from
`*Model*`.

Thereafter, the list of rules is retrieved from the `*RuleManager*`. The `*RuleEngine*` iterates through the list,
using the `*RulePredicate*` and `*RuleAction*` of each rule to create the required `*Testable*` for testing on the
transaction, as well as the `*Performable*` for performing the action.

The following activity diagram shows in greater detail the workflow of executing rules.

.Activity diagram of the different paths involved in the workflow of executing rules
image::RuleExecutionActivityDiagram.png[]

The activity diagram above has a slightly different context as the sequence diagram, to show a separate use case. In this
diagram, instead of a new transaction that is added, we have a transaction that is edited. Both types of commands do not affect
the workflow of rule execution.

In this diagram, the generation of a `*Testable*` and `*Performable*` is shown in greater detail.

`*Testable*` is an interface which, like `*RulePredicate*`, have its implementations split into expressions and scripts,
namely `*TestableExpression*` and `*TestableScript*`.

Similarly, `*Performable*` is an interface which, like `*RuleAction*`, have its implementations split into expressions
and scripts, namely `*PerformableExpression*` and `*PerformableScript*`.

Expressions are generated by the `*RuleEngine*` when either the `*RulePredicate*` or `*RuleAction*` are of the expression type.
The `*RuleEngine*` will retrieve the correct expression constructor from an internal hash map based on the `*Operator*`,
and create the expression using the given attribute and/or value.

****
For example, we have an predicate `p/desc contains food`. One of the classes implementing `*TestableExpression*`,
`*ContainsExpression*`, is created since the predicate has the *Operator:* `contains`. The corresponding *Attribute:* `desc`
and *Value:* `food` in the predicate are provided into the `*ContainsExpression*` constructor during instantiation.
****

Scripts, on the other hand, are generated by the `*RuleEngine*` when either the `*RulePredicate*` or `*RuleAction*` are of
the script type. The `*RuleEngine*` will generate the corresponding `*Testable*` or `*Performable*` by first retrieving
the script from the `*ScriptLibrary*` based on its `*ScriptName*`. Following that, a `*TestableScript*` or `*PerformableScript*`
is instantiated with a function `*ScriptEvaluator*`, which evaluates the script given the transaction and account. This
function is then called when `*Testable#test*` or `*Performable#perform*` is executed.

==== Design Considerations
===== Aspect: Duplication of predicates and actions in model and logic
* **Alternative 1 (current choice)**: Both predicates and actions have their corresponding versions in both model and logic.
** Pros: Able to split the logic flow and execution code from the data in model.
** Cons: Seemingly duplicate classes, such as `*PredicateExpression*` and `*TestableExpression*`, which increases the number
of classes.
* **Alternative 2**: All execution data and logic is stored in the rule model rather than logic.
** Pros: Reduce class duplication, less confusion.
** Cons: `*Model*` and `*Logic*` will have unnecessary coupling which reduces testability and makes maintenance and integration harder.
// end::ruleExec[]

// tag::importexport[]
=== Import and export
==== Implementation

The import functionality takes in a file and parses it into ``Transaction``s.

All of the supported formats are comma-separated value (CSV) files. The bulk of
the work is parsing the different ways the different banks represent the same data,
and mapping each column from bank transaction export into the fields contained by
Budget Buddy ``Transaction``s.

The following class diagram illustrates the design of the import and export function.

_TODO: Class diagram_

==== Design considerations

_TODO_
// end::importexport[]

// tag::scripts[]
=== Scripting
==== Implementation

The scripting engine works independently of the rest of the application.
At its core, it uses the Nashorn ECMAScript 5.1 engine bundled with Java 11 to
evaluate scripts.

A set of convenience functions are provided to make basic tasks, such as manipulating
transactions and accounts, easier. The full model and UI are nevertheless exposed to
scripts, and scripts are able to access any classes provided in the Java 11 standard
library, as well as any dependencies included in the application.

There is a simple mechanism to store scripts to be run in future. This works together
with rules to give the ability to have complex predicates and actions outside of
those supported inherently by the program. This also works with aliases to allow,
in effect, custom commands to be created.

The following class diagram illustrates the design of the scripting engine and model.

_TODO: Class diagram_

==== Design considerations

_TODO_
// end::scripts[]

// tag::aliases[]
=== Aliases
==== Implementation

The alias is a simple hook into the command parsing engine. If there is no
built-in command corresponding to a command line, then the alias map is checked.
If there is a matching alias, then the alias name in the command line is replaced,
and the command execution is re-tried.

To prevent alias loops where the user creates an alias `x` mapping to `y`, and an
alias `y` mapping to `x`, we track the aliases that have been applied, and
stop evaluation if we see that the same alias has been applied more than once.

==== Design considerations

_TODO_
// end::aliases[]

// tag::undoredo[]
=== [Proposed] Undo/Redo feature
==== Proposed Implementation

The undo/redo mechanism is facilitated by `VersionedAddressBook`.
It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedAddressBook#commit()` -- Saves the current address book state in its history.
* `VersionedAddressBook#undo()` -- Restores the previous address book state from its history.
* `VersionedAddressBook#redo()` -- Restores a previously undone address book state from its history.

These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

image::UndoRedoState0.png[]

Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

image::UndoRedoState1.png[]

Step 3. The user executes `add n/David ...` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

image::UndoRedoState2.png[]

[NOTE]
If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

image::UndoRedoState3.png[]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial address book state, then there are no previous address book states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoSequenceDiagram.png[]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

The `redo` command does the opposite -- it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

[NOTE]
If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone address book states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

image::UndoRedoState4.png[]

Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.

image::UndoRedoState5.png[]

The following activity diagram summarizes what happens when a user executes a new command:

image::CommitActivityDiagram.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of address book states.
** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
// end::undoredo[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage expenses and income over a significant period of time
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps
* capable of basic programming to customize the app to their liking

*Value proposition*: manage expenses/income faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |user |see an overview of all my spending from month to month |better judge my expense/income ratio

|`* * *` |user who borrows and loans money frequently |track who owes me money/who I owe money to |settle my debts

|`* * *` |careful spender |dedicate different accounts to different holidays |control how much I spend while on the holidays

|`* * *` |busy user |keep track of my spending in different account books |segregate completely unrelated spending

|`* * *` |SoC student experienced in writing programs |write my own scripts to manipulate entries in the app |automate and customize the app to my liking

|`* *` |spendthrift |set a budget for my monthly spending |avoid breaking the bank again

|`* *` |lazy user |key in recurring expenses just once |do not have to enter them over and over again

|`* *` |careful spender |make month-to-month comparisons of spending in a particular category |see where additional expenses for certain months come from

|`* *` |cautious spender |carry over any budget deficits incurred each month to the following month |remember to repay it

|`* *` |SoC student who has to pay school fees regularly |track how much Iâ€™ll have to pay and when I have to pay it by |avoid making late payments

|`* *` |ambitious user |set goals for my cumulative income |work towards my dream home/car/goal

|`* *` |careless user |undo a mistake |not worry even if I accidentally make an error

|`* *` |careful spender |set different currencies for different accounts |see my expenditure during a holiday in the local currency

|`* *` |lazy person |import expenses from csv exports from internet banking |transfer my records across software

|`* *` |supremely lazy user |have the program detect recurring transactions and suggest them to me |not waste time adding them manually

|`* *` |paranoid user |have the program show me all possible commands and how to use them |know exactly what I am doing

|`* *` |user who prefers visuals |see a chart of my budget spending across past months |see how much I have been overspending/underspending

|`* *` |busy user |move and delete multiple transactions at the same time |be more efficient

|`* *` |lazy user |have the program autofill my command as I am typing it |enter my transactions more quickly

|`* *` |user who cannot control spending |set a budget for different purposes |control my spending

|`* *` |lazy user |have the app to have predictive commands based on what transactions I commonly include |spend less time typing in my expenses

|`* *` |fast typer |type out multiple commands all at once |type the next command without having to pause

|`* *` |person who occasionally goes overseas |assign an exchange rate to each foreign currency transaction |get reports on my total expenditure in my home currency

|`* *` |busy user |see my overall budget surplus/deficit at a glance |know straight away when Iâ€™m below or above my budget for that month

|`* *` |meticulous user |see how much I need to budget every month to reach a savings goal based on what the goal is and its deadline |plan my budget well

|`*` |unmotivated person |be rewarded for entering my expenses/income daily |be motivated to do so and eventually turn it into a habit

|`*` |expense planner |record down possible future expenses |keep track of what I planned to spend on

|`*` |forgetful user |have the app set reminders |keep track of my spending everyday

|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is `Budget Buddy` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Delete transaction

*MSS*

1.  User requests to list transactions.
2.  Budget Buddy shows a list of transactions for the current account.
3.  User requests to delete a specific transaction in the list.
4.  Budget Buddy deletes the transaction.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. Budget Buddy shows an error message.
+
Use case resumes at step 2.

=== Use case: Add loan

*MSS*

1.  User requests to add a <<loan-out, loan out>>.
2.  Budget Buddy adds the loan for the given person.
+
Use case ends.

*Extensions*

[none]
* 1a. The given loan out value is not positive.
+
[none]
** 1a1. Budget Buddy shows an error message.
+
Use case resumes at step 1.

=== Use case: Edit loan

*MSS*

1.  User requests to list loans.
2.  Budget Buddy shows a list of loans.
3.  User requests to edit the description of a loan in the list.
4.  Budget Buddy edits the description of the specified loan.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 2a. The given loan index is invalid.
+
[none]
** 2a1. Budget Buddy shows an error message.
+
Use case resumes at step 2.

=== Use case: Add account

*MSS*

1. User requests to add a new account.
2. Budget Buddy creates the new account.
+
Use case ends.

*Extensions*

[none]
* 1a. No account name was provided.
+
[none]
** 1a1. Budget Buddy shows an error message.
+
Use case resumes at step 1.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000000 transactions without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[loan-out]] Loan Out::
A loan where the user has lent money to another person.

[[loan-in]] Loan In::
A loan where the user has borrowed money from another person.

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

=== Deleting an account

. Deleting an account while all accounts are listed

.. Prerequisites: List all persons using the `account list` command. More than one account in the list.
.. Test case: `account delete 1` +
   Expected: First account is deleted from the list. Details of the deleted account shown in the status message.
.. Test case: `account delete 0` +
   Expected: No account is deleted. Error details shown in the status message.
.. Other incorrect delete commands to try: `account delete`, `account delete x` (where x is larger than the list size) +
   Expected: Similar to previous.
